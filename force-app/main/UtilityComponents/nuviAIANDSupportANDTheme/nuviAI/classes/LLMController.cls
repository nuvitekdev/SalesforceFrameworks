public with sharing class LLMController {
    /**
     * Mock configuration for testing purposes
     * This allows test classes to inject mock LLM configurations without database queries
     */
    @TestVisible
    private static List<LLM_Configuration__mdt> mockConfigurations = new List<LLM_Configuration__mdt>();

    @AuraEnabled(cacheable=true)
    public static List<LLM_Configuration__mdt> getLLMConfigurations() {
        System.debug('Getting LLM configurations');
        List<LLM_Configuration__mdt> configs = [SELECT Id, DeveloperName, MasterLabel, Provider__c, 
                                                Model_Name__c, Supports_Files__c 
                                                FROM LLM_Configuration__mdt 
                                                WHERE IsActive__c = true];
        System.debug('Found configurations: ' + configs.size());
        return configs;
    }
    
    @AuraEnabled
    public static String handleRequest(String recordId, String configName, String prompt, String operation, String relatedObjects, String reportObjects) {
        System.debug('Handle request started');
        System.debug('Parameters - recordId: ' + recordId + ', configName: ' + configName + ', operation: ' + operation + ', reportObjects: ' + reportObjects);
        
        try {
            // Validate configName is provided
            if (String.isBlank(configName)) {
                throw new AuraHandledException('Error: AI Model Configuration Name is required. Please select an AI model from the dropdown.');
            }
            
            LLM_Configuration__mdt config = [SELECT API_Key__c, Base_URL__c, Model_Name__c, 
                                             Provider__c, Supports_Files__c, Max_Tokens__c, Temperature__c
                                             FROM LLM_Configuration__mdt 
                                             WHERE DeveloperName = :configName 
                                             LIMIT 1];
            
            String context = '';
            String attachments = '';
            
            // Only get record context if a recordId is provided
            if (String.isNotBlank(recordId)) {
                context = getRecordContext(recordId, relatedObjects);
                
                attachments = config.Supports_Files__c ? getAttachmentsBase64(recordId) : '';
            }
            
            // Add report data if reportObjects is provided
            if (String.isNotBlank(reportObjects)) {
                context += getReportData(reportObjects);
            }
            
            String fullPrompt = buildFullPrompt(operation, context, attachments, prompt);
            System.debug('Full prompt length: ' + fullPrompt.length());
            
            return makeLLMCall(config, fullPrompt);
        } catch(Exception e) {
            System.debug('ERROR in handleRequest: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            throw new AuraHandledException('Error: ' + e.getMessage());
        }
    }
    
    /**
     * @description Checks a given record for potential anomalies, conflicts of interest, or inconsistencies using an AI model.
     * @param recordId The Id of the Salesforce record to analyze.
     * @param configName The DeveloperName of the LLM_Configuration__mdt to use.
     * @param relatedObjects Comma-separated list of object API names to search across for related data.
     * @return String The AI's assessment (e.g., "YES - Conflict of interest detected: Submitter and Investigator are the same." or "NO").
     * @throws AuraHandledException if an error occurs during processing.
     */
    @AuraEnabled
    public static String checkRecordForAnomalies(String recordId, String configName, String relatedObjects) {
        System.debug('Anomaly check started for recordId: ' + recordId + ' using config: ' + configName);

        // Validate inputs
        if (String.isBlank(recordId) || String.isBlank(configName)) {
            System.debug('ERROR in checkRecordForAnomalies: Missing recordId or configName.');
            throw new AuraHandledException('Error: Record ID and AI Model Configuration Name are required.');
        }

        try {
            // Fetch the specified LLM configuration
            LLM_Configuration__mdt config = [SELECT API_Key__c, Base_URL__c, Model_Name__c, 
                                             Provider__c, Supports_Files__c, Max_Tokens__c, Temperature__c
                                             FROM LLM_Configuration__mdt 
                                             WHERE DeveloperName = :configName 
                                             LIMIT 1];

            // Get the context for the specified record
            String context = getRecordContext(recordId, relatedObjects);
            
            // Construct the prompt specifically for anomaly detection
            String anomalyPrompt = 'Analyze the following Salesforce record data. Look specifically for potential issues such as: \n' + 
                                 '- Anomalies (e.g., unusual values, missing required information for the stage)\n' +
                                 '- Conflicts of Interest (e.g., the same person involved in conflicting roles like submitter and approver)\n' + 
                                 '- Inconsistencies (e.g., dates out of order, contradictory statements)\n' +
                                 '- Any other red flags or data points that seem incorrect or warrant further investigation.\n\n' +
                                 'Your response MUST start with either "YES - " followed by the explanation, or "NO" if no significant issues are detected.\n\n' +
                                 'IMPORTANT FORMATTING INSTRUCTIONS: If issues are found (starting with "YES - "), format the explanation using basic HTML:\n' +
                                 '  - Use <b> tags to highlight main points or titles (e.g., <b>Conflict of Interest</b>).\n' +
                                 '  - Use <ol> and <li> for numbered lists of main findings.\n' +
                                 '  - Use <ul> and <li> for bullet points under each finding or for recommendations.\n' +
                                 '  - Use <br> for line breaks where appropriate. Do NOT include the markdown `-` for bullets, use <li> instead.\n\n' +
                                 'RECORD DATA:\n' + context;

            // Call the LLM with the specific anomaly detection prompt
            String assessment = makeLLMCall(config, anomalyPrompt);
            System.debug('Anomaly check completed successfully');
            
            // Return the raw assessment from the LLM
            return assessment;

        } catch(Exception e) {
            // Log detailed error information
            System.debug('ERROR in checkRecordForAnomalies: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            // Throw a user-friendly exception
            throw new AuraHandledException('Error performing AI anomaly check: ' + e.getMessage());
        }
    }
    
    private static String getRecordContext(String recordId, String relatedObjects) {
        try {
            // Identify object type from record ID
            Schema.SObjectType objectType = Id.valueOf(recordId).getSObjectType();
            String objectName = objectType.getDescribe().getName();
            System.debug('Object type for record: ' + objectName);
            
            // Build a query for all accessible fields on this object
            Map<String, Schema.SObjectField> fieldMap = objectType.getDescribe().fields.getMap();
            List<String> fieldNames = new List<String>();
            
            for (String fieldName : fieldMap.keySet()) {
                Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe();
                if (field.isAccessible()) {
                    fieldNames.add(fieldName);
                }
            }
            
            // Build and execute dynamic query
            String query = 'SELECT ' + String.join(fieldNames, ',') + ' FROM ' + objectName + ' WHERE Id = :recordId LIMIT 1';
            SObject record = Database.query(query);
            System.debug('Record retrieved: ' + record);
            
            // Start building rich context
            String context = '\nRECORD DETAILS:\n';
            
            // Add all field values to context
            for (String fieldName : fieldNames) {
                Object fieldValue = record.get(fieldName);
                if (fieldValue != null) {
                    context += 'â€¢ ' + fieldMap.get(fieldName).getDescribe().getLabel() + ': ' + fieldValue + '\n';
                }
            }
            
            // Get relationship fields (lookups and master-detail)
            List<String> relationshipFields = new List<String>();
            for (String fieldName : fieldMap.keySet()) {
                Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe();
                if (field.getType() == Schema.DisplayType.REFERENCE && field.isAccessible()) {
                    relationshipFields.add(fieldName);
                }
            }
            
            // Add related record info if there are relationships
            if (!relationshipFields.isEmpty()) {
                context += '\nRELATED RECORDS:\n';
                for (String relField : relationshipFields) {
                    Id relatedId = (Id)record.get(relField);
                    if (relatedId != null) {
                        String relatedObjName = relatedId.getSObjectType().getDescribe().getName();
                        String relatedLabel = fieldMap.get(relField).getDescribe().getLabel();
                        
                        try {
                            // Get name field of related object if possible
                            String nameQuery = 'SELECT Name FROM ' + relatedObjName + ' WHERE Id = :relatedId LIMIT 1';
                            List<SObject> relatedRecords = Database.query(nameQuery);
                            if (!relatedRecords.isEmpty()) {
                                context += 'â€¢ ' + relatedLabel + ': ' + relatedRecords[0].get('Name') + '\n';
                            }
                        } catch (Exception e) {
                            // Some objects might not have a Name field
                            context += 'â€¢ ' + relatedLabel + ': ' + relatedId + '\n';
                        }
                    }
                }
            }
            
            // Get field history tracking data
            context += getFieldHistoryData(recordId, objectName);
            
            // Get child relationships (line items, invoices, etc.)
            context += getChildRelationships(recordId, objectType);

            // Get activity history for context (works for most standard objects)
            try {
                List<Task> recentTasks = [SELECT Subject, ActivityDate, Status, Owner.Name, Description
                                         FROM Task
                                         WHERE WhatId = :recordId
                                         ORDER BY ActivityDate DESC
                                         LIMIT 5];
                
                if (!recentTasks.isEmpty()) {
                    context += '\nRECENT TASKS:\n';
                    for (Task t : recentTasks) {
                        context += 'â€¢ ' + t.Subject + ' (' + t.Status + ')';
                        if (t.ActivityDate != null) {
                            context += ' due ' + t.ActivityDate.format();
                        }
                        context += ' - ' + t.Owner.Name + '\n';
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching tasks: ' + e.getMessage());
            }
            
            // Get events and meetings (calendar items)
            try {
                List<Event> recentEvents = [SELECT Subject, StartDateTime, EndDateTime, Location, Description, OwnerId, Owner.Name
                                           FROM Event 
                                           WHERE WhatId = :recordId
                                           ORDER BY StartDateTime DESC 
                                           LIMIT 5];
                
                if (!recentEvents.isEmpty()) {
                    context += '\nRECENT EVENTS & MEETINGS:\n';
                    for (Event e : recentEvents) {
                        String dateTimeFormat = e.StartDateTime != null ? e.StartDateTime.format('MMM d, yyyy h:mm a') : 'Unknown date';
                        String endTimeFormat = e.EndDateTime != null ? ' - ' + e.EndDateTime.format('h:mm a') : '';
                        String location = String.isNotBlank(e.Location) ? ' (' + e.Location + ')' : '';
                        
                        context += 'â€¢ ' + e.Subject + ' on ' + dateTimeFormat + endTimeFormat + location + ' - ' + e.Owner.Name + '\n';
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching events: ' + e.getMessage());
            }
            
            // Get emails related to the record (EmailMessage)
            try {
                List<EmailMessage> recentEmails = [SELECT Subject, MessageDate, FromAddress, ToAddress, CcAddress, Status, HtmlBody
                                                  FROM EmailMessage 
                                                  WHERE RelatedToId = :recordId 
                                                  ORDER BY MessageDate DESC 
                                                  LIMIT 5];
                
                if (!recentEmails.isEmpty()) {
                    context += '\nRECENT EMAILS:\n';
                    for (EmailMessage em : recentEmails) {
                        context += 'â€¢ ' + em.Subject + ' (' + (em.MessageDate != null ? em.MessageDate.format() : 'Unknown date') + ')\n';
                        context += '  From: ' + em.FromAddress + '\n';
                        context += '  To: ' + em.ToAddress + '\n';
                        
                        // Add short snippet of the email body
                        if (em.HtmlBody != null) {
                            // Strip HTML and get truncated preview
                            String plainBody = em.HtmlBody.replaceAll('<[^>]+>', ' ').replaceAll('\\s+', ' ').trim();
                            if (plainBody.length() > 200) {
                                plainBody = plainBody.substring(0, 197) + '...';
                            }
                            context += '  Preview: ' + plainBody + '\n';
                        }
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching emails: ' + e.getMessage());
            }
            
            // Get any Notes related to the record
            try {
                // First, get ContentDocumentLink records
                List<ContentDocumentLink> contentLinks = [
                    SELECT ContentDocumentId 
                    FROM ContentDocumentLink 
                    WHERE LinkedEntityId = :recordId
                ];
                
                if (!contentLinks.isEmpty()) {
                    // Extract ContentDocumentIds
                    Set<Id> contentDocIds = new Set<Id>();
                    for (ContentDocumentLink link : contentLinks) {
                        contentDocIds.add(link.ContentDocumentId);
                    }
                    
                    // Then query for ContentNote records
                    List<ContentNote> notes = [
                        SELECT Id, Title, Content, CreatedDate, CreatedBy.Name
                        FROM ContentNote
                        WHERE Id IN :contentDocIds
                        ORDER BY CreatedDate DESC
                        LIMIT 5
                    ];
                    
                    if (!notes.isEmpty()) {
                        context += '\nNOTES:\n';
                        for (ContentNote note : notes) {
                            context += 'â€¢ ' + note.Title + ' (Created by ' + note.CreatedBy.Name + ' on ' + note.CreatedDate.format() + ')\n';
                            
                            // Convert the note content from Base64 to readable text
                            if (note.Content != null) {
                                String noteBody = note.Content.toString();
                                if (noteBody.length() > 300) {
                                    noteBody = noteBody.substring(0, 297) + '...';
                                }
                                context += '  ' + noteBody.replaceAll('\n', '\n  ') + '\n';
                            }
                        }
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching notes: ' + e.getMessage());
            }
            
            // Get collaboration activity (works for feed-enabled objects)
            try {
                List<FeedItem> recentPosts = [SELECT CreatedBy.Name, Body, CreatedDate, CommentCount
                                             FROM FeedItem
                                             WHERE ParentId = :recordId
                                             ORDER BY CreatedDate DESC
                                             LIMIT 5];
                
                if (!recentPosts.isEmpty()) {
                    context += '\nRECENT CHATTER POSTS:\n';
                    for (FeedItem post : recentPosts) {
                        String commentInfo = post.CommentCount > 0 ? ' (' + post.CommentCount + ' comments)' : '';
                        context += 'â€¢ ' + post.CreatedBy.Name + ' on ' + post.CreatedDate.format() + commentInfo + ':\n';
                        context += '  "' + post.Body.abbreviate(200).replaceAll('\n', '\n  ') + '"\n';
                        
                        // Get comments for the post if there are any
                        if (post.CommentCount > 0) {
                            try {
                                List<FeedComment> comments = [SELECT CreatedBy.Name, CommentBody, CreatedDate
                                                             FROM FeedComment
                                                             WHERE FeedItemId = :post.Id
                                                             ORDER BY CreatedDate ASC
                                                             LIMIT 3];
                                
                                for (FeedComment comment : comments) {
                                    context += '    â†³ ' + comment.CreatedBy.Name + ' replied on ' + comment.CreatedDate.format() + ':\n';
                                    context += '      "' + comment.CommentBody.abbreviate(100).replaceAll('\n', '\n      ') + '"\n';
                                }
                                
                                // Indicate if there are more comments
                                if (post.CommentCount > 3) {
                                    context += '    â†³ ' + (post.CommentCount - 3) + ' more comments\n';
                                }
                            } catch (Exception e) {
                                System.debug('Error fetching comments: ' + e.getMessage());
                            }
                        }
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching feed items: ' + e.getMessage());
            }
            
            // Include document summaries
            context += getDocumentSummaries(recordId);
            
            // Check for common important related objects based on the object type
            context += getCommonRelatedObjectsContext(objectName, recordId);
            
            // Include related objects data if specified
            if (String.isNotBlank(relatedObjects)) {
                context += getRelatedObjectsData(recordId, relatedObjects);
            }
            
            return context;
        } catch (Exception e) {
            System.debug('ERROR in getRecordContext: ' + e.getMessage());
            throw new AuraHandledException('Failed to get record context: ' + e.getMessage());
        }
    }
    
    /**
     * @description Get context for common related objects based on the parent object type
     * This method handles fetching important related objects specific to the record's object type
     * @param objectName API name of the parent object
     * @param recordId Id of the parent record
     * @return String Formatted text with related object information
     */
    private static String getCommonRelatedObjectsContext(String objectName, String recordId) {
        String context = '';
        Integer MAX_RECORDS = 10; // Maximum records to return per related object
        
        try {
            // For Account records, get related contacts, opportunities, and cases
            if (objectName == 'Account') {
                // Get related contacts
                try {
                    List<Contact> contacts = [SELECT Id, Name, Title, Email, Phone 
                                             FROM Contact 
                                             WHERE AccountId = :recordId
                                             ORDER BY LastModifiedDate DESC 
                                             LIMIT :MAX_RECORDS];
                    
                    if (!contacts.isEmpty()) {
                        context += '\nRELATED CONTACTS:\n';
                        for (Contact c : contacts) {
                            context += 'â€¢ ' + c.Name;
                            if (String.isNotBlank(c.Title)) context += ', ' + c.Title;
                            if (String.isNotBlank(c.Email)) context += ' (Email: ' + c.Email + ')';
                            if (String.isNotBlank(c.Phone)) context += ' (Phone: ' + c.Phone + ')';
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying related contacts: ' + e.getMessage());
                }
                
                // Get related opportunities
                try {
                    List<Opportunity> opportunities = [SELECT Id, Name, StageName, Amount, CloseDate
                                                      FROM Opportunity
                                                      WHERE AccountId = :recordId
                                                      ORDER BY CloseDate DESC
                                                      LIMIT :MAX_RECORDS];
                    
                    if (!opportunities.isEmpty()) {
                        context += '\nRELATED OPPORTUNITIES:\n';
                        for (Opportunity o : opportunities) {
                            context += 'â€¢ ' + o.Name + ' - ' + o.StageName;
                            if (o.Amount != null) context += ' - $' + o.Amount;
                            if (o.CloseDate != null) context += ' (Close Date: ' + o.CloseDate.format() + ')';
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying related opportunities: ' + e.getMessage());
                }
                
                // Get related cases
                try {
                    List<Case> cases = [SELECT Id, CaseNumber, Subject, Status, Priority, CreatedDate
                                       FROM Case
                                       WHERE AccountId = :recordId
                                       ORDER BY CreatedDate DESC
                                       LIMIT :MAX_RECORDS];
                    
                    if (!cases.isEmpty()) {
                        context += '\nRELATED CASES:\n';
                        for (Case c : cases) {
                            context += 'â€¢ Case #' + c.CaseNumber + ': ' + c.Subject;
                            context += ' - Status: ' + c.Status + ', Priority: ' + c.Priority;
                            context += ' (Created: ' + c.CreatedDate.format() + ')';
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying related cases: ' + e.getMessage());
                }
            }
            
            // For Contact records, get related opportunities and cases
            else if (objectName == 'Contact') {
                // Get related opportunities
                try {
                    List<Opportunity> opportunities = [SELECT Id, Name, StageName, Amount, CloseDate
                                                      FROM Opportunity
                                                      WHERE ContactId = :recordId  // Primary contact
                                                      ORDER BY CloseDate DESC
                                                      LIMIT :MAX_RECORDS];
                    
                    if (!opportunities.isEmpty()) {
                        context += '\nRELATED OPPORTUNITIES:\n';
                        for (Opportunity o : opportunities) {
                            context += 'â€¢ ' + o.Name + ' - ' + o.StageName;
                            if (o.Amount != null) context += ' - $' + o.Amount;
                            if (o.CloseDate != null) context += ' (Close Date: ' + o.CloseDate.format() + ')';
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying related opportunities: ' + e.getMessage());
                }
                
                // Get related cases
                try {
                    List<Case> cases = [SELECT Id, CaseNumber, Subject, Status, Priority, CreatedDate
                                       FROM Case
                                       WHERE ContactId = :recordId
                                       ORDER BY CreatedDate DESC
                                       LIMIT :MAX_RECORDS];
                    
                    if (!cases.isEmpty()) {
                        context += '\nRELATED CASES:\n';
                        for (Case c : cases) {
                            context += 'â€¢ Case #' + c.CaseNumber + ': ' + c.Subject;
                            context += ' - Status: ' + c.Status + ', Priority: ' + c.Priority;
                            context += ' (Created: ' + c.CreatedDate.format() + ')';
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying related cases: ' + e.getMessage());
                }
            }
            
            // For Case records, get related contact, account and case comments
            else if (objectName == 'Case') {
                // Get case comments
                try {
                    List<CaseComment> comments = [SELECT Id, CommentBody, CreatedDate, CreatedBy.Name, IsPublished
                                                 FROM CaseComment
                                                 WHERE ParentId = :recordId
                                                 ORDER BY CreatedDate DESC
                                                 LIMIT :MAX_RECORDS];
                    
                    if (!comments.isEmpty()) {
                        context += '\nCASE COMMENTS:\n';
                        for (CaseComment cc : comments) {
                            String visibilityInfo = cc.IsPublished ? 'Public' : 'Private';
                            context += 'â€¢ ' + cc.CreatedBy.Name + ' (' + cc.CreatedDate.format() + ') - ' + visibilityInfo + ':\n';
                            
                            // Format comment text with indentation
                            String commentText = cc.CommentBody;
                            if (commentText != null) {
                                if (commentText.length() > 300) {
                                    commentText = commentText.substring(0, 297) + '...';
                                }
                                context += '  ' + commentText.replaceAll('\n', '\n  ') + '\n';
                            }
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying case comments: ' + e.getMessage());
                }
            }
            
            // For Opportunity records, get related contacts, products, quotes
            else if (objectName == 'Opportunity') {
                // Get opportunity contact roles
                try {
                    List<OpportunityContactRole> contactRoles = [SELECT Id, ContactId, Contact.Name, Contact.Title, Role
                                                                FROM OpportunityContactRole
                                                                WHERE OpportunityId = :recordId
                                                                ORDER BY CreatedDate DESC
                                                                LIMIT :MAX_RECORDS];
                    
                    if (!contactRoles.isEmpty()) {
                        context += '\nOPPORTUNITY CONTACT ROLES:\n';
                        for (OpportunityContactRole ocr : contactRoles) {
                            context += 'â€¢ ' + ocr.Contact.Name;
                            if (String.isNotBlank(ocr.Contact.Title)) context += ', ' + ocr.Contact.Title;
                            if (String.isNotBlank(ocr.Role)) context += ' - Role: ' + ocr.Role;
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying opportunity contact roles: ' + e.getMessage());
                }
                
                // Get opportunity line items (products)
                try {
                    List<OpportunityLineItem> lineItems = [SELECT Id, Product2.Name, Quantity, UnitPrice, TotalPrice, Description
                                                          FROM OpportunityLineItem
                                                          WHERE OpportunityId = :recordId
                                                          ORDER BY CreatedDate DESC
                                                          LIMIT :MAX_RECORDS];
                    
                    if (!lineItems.isEmpty()) {
                        context += '\nOPPORTUNITY PRODUCTS:\n';
                        for (OpportunityLineItem oli : lineItems) {
                            context += 'â€¢ ' + oli.Product2.Name;
                            if (oli.Quantity != null) context += ' - Qty: ' + oli.Quantity;
                            if (oli.UnitPrice != null) context += ' - Unit Price: $' + oli.UnitPrice;
                            if (oli.TotalPrice != null) context += ' - Total: $' + oli.TotalPrice;
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying opportunity line items: ' + e.getMessage());
                }
            }
            
            // For Lead records, get conversion status and activities
            else if (objectName == 'Lead') {
                // If lead is converted, get converted account/contact/opportunity
                try {
                    Lead leadRecord = [SELECT Id, IsConverted, ConvertedAccountId, ConvertedContactId, ConvertedOpportunityId 
                                      FROM Lead 
                                      WHERE Id = :recordId 
                                      LIMIT 1];
                    
                    if (leadRecord.IsConverted) {
                        context += '\nLEAD CONVERSION DETAILS:\n';
                        
                        if (leadRecord.ConvertedAccountId != null) {
                            Account convertedAccount = [SELECT Id, Name FROM Account WHERE Id = :leadRecord.ConvertedAccountId LIMIT 1];
                            context += 'â€¢ Converted to Account: ' + convertedAccount.Name + '\n';
                        }
                        
                        if (leadRecord.ConvertedContactId != null) {
                            Contact convertedContact = [SELECT Id, Name FROM Contact WHERE Id = :leadRecord.ConvertedContactId LIMIT 1];
                            context += 'â€¢ Converted to Contact: ' + convertedContact.Name + '\n';
                        }
                        
                        if (leadRecord.ConvertedOpportunityId != null) {
                            Opportunity convertedOpp = [SELECT Id, Name, StageName, Amount, CloseDate 
                                                       FROM Opportunity 
                                                       WHERE Id = :leadRecord.ConvertedOpportunityId 
                                                       LIMIT 1];
                            
                            context += 'â€¢ Converted to Opportunity: ' + convertedOpp.Name;
                            if (convertedOpp.Amount != null) context += ' - $' + convertedOpp.Amount;
                            context += ' - ' + convertedOpp.StageName;
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying lead conversion details: ' + e.getMessage());
                }
            }

            // For any object, try to get recent modified related records
            context += getRecentModifiedRelatedRecords(recordId, MAX_RECORDS);
            
            return context;
        } catch (Exception e) {
            System.debug('ERROR in getCommonRelatedObjectsContext: ' + e.getMessage());
            return '\nError fetching common related objects: ' + e.getMessage();
        }
    }
    
    /**
     * @description Gets a summary of recently modified records linked to this record
     * @param recordId The Id of the primary Salesforce record
     * @param maxRecords The maximum number of records to return
     * @return String Formatted text with recently modified related record information
     */
    private static String getRecentModifiedRelatedRecords(String recordId, Integer maxRecords) {
        String context = '';
        
        try {
            // Get ContentDocumentLinks for this record
            List<ContentDocumentLink> links = [SELECT ContentDocumentId, LinkedEntityId 
                                              FROM ContentDocumentLink 
                                              WHERE LinkedEntityId = :recordId];
            
            // Get ContentDocumentIds
            Set<Id> contentDocIds = new Set<Id>();
            for (ContentDocumentLink link : links) {
                contentDocIds.add(link.ContentDocumentId);
            }
            
            // Join with a general modified query
            // This uses a SOSL search to find records connected to our record
            if (!Test.isRunningTest()) { // SOSL is not supported in tests
                String searchQuery = 'FIND \'' + recordId + '\' IN ALL FIELDS RETURNING ';
                
                // Add standard objects commonly referenced
                searchQuery += 'Account(Id, Name, LastModifiedDate ORDER BY LastModifiedDate DESC LIMIT ' + maxRecords + '), ';
                searchQuery += 'Contact(Id, Name, LastModifiedDate ORDER BY LastModifiedDate DESC LIMIT ' + maxRecords + '), ';
                searchQuery += 'Opportunity(Id, Name, StageName, LastModifiedDate ORDER BY LastModifiedDate DESC LIMIT ' + maxRecords + '), ';
                searchQuery += 'Case(Id, CaseNumber, Subject, Status, LastModifiedDate ORDER BY LastModifiedDate DESC LIMIT ' + maxRecords + ')';
                
                // Execute the search
                List<List<SObject>> searchResults = Search.query(searchQuery);
                
                if (searchResults != null && !searchResults.isEmpty()) {
                    context += '\nRECENTLY MODIFIED CONNECTED RECORDS:\n';
                    
                    for (List<SObject> objList : searchResults) {
                        if (objList == null || objList.isEmpty()) continue;
                        
                        String objType = objList[0].getSObjectType().getDescribe().getName();
                        
                        for (SObject obj : objList) {
                            Datetime lastModified = (Datetime)obj.get('LastModifiedDate');
                            if (lastModified == null) continue;
                            
                            context += 'â€¢ ' + objType + ': ';
                            
                            // Name or equivalent
                            if (obj.get('Name') != null) {
                                context += (String)obj.get('Name');
                            } else if (obj.get('CaseNumber') != null) {
                                context += 'Case #' + (String)obj.get('CaseNumber');
                                if (obj.get('Subject') != null) {
                                    context += ': ' + (String)obj.get('Subject');
                                }
                            } else {
                                context += 'Record ' + obj.Id;
                            }
                            
                            // Status if available
                            if (obj.get('Status') != null) {
                                context += ' - ' + (String)obj.get('Status');
                            } else if (obj.get('StageName') != null) {
                                context += ' - ' + (String)obj.get('StageName');
                            }
                            
                            // Last modified date
                            context += ' (Modified: ' + lastModified.format() + ')\n';
                        }
                    }
                }
            }
            
            return context;
        } catch (Exception e) {
            System.debug('ERROR in getRecentModifiedRelatedRecords: ' + e.getMessage());
            return '';
        }
    }
    
    private static String getDocumentSummaries(String recordId) {
        try {
            // First get the ContentDocumentLinks
            List<ContentDocumentLink> links = [SELECT ContentDocumentId 
                                               FROM ContentDocumentLink 
                                               WHERE LinkedEntityId = :recordId];
            
            if(links.isEmpty()) {
                return '\nNO DOCUMENTS ATTACHED';
            }
            
            // Get the ContentDocument IDs
            Set<Id> contentDocIds = new Set<Id>();
            for(ContentDocumentLink link : links) {
                contentDocIds.add(link.ContentDocumentId);
            }
            
            // Then get the ContentVersions
            List<ContentVersion> versions = [SELECT Title, FileExtension, FileType, Description 
                                             FROM ContentVersion 
                                             WHERE ContentDocumentId IN :contentDocIds
                                             AND IsLatest = true];
            
            String summaries = '\nATTACHED DOCUMENTS:\n';
            for(ContentVersion doc : versions) {
                summaries += 'â€¢ ' + doc.Title;
                if(doc.Description != null) {
                    // Truncate description if too long
                    String description = doc.Description;
                    if(description.length() > 500) {
                        description = description.substring(0, 497) + '...';
                    }
                    summaries += ' - ' + description;
                }
                summaries += ' (' + doc.FileType + ')\n';
            }
            return summaries;
        } catch(Exception e) {
            System.debug('ERROR getting document summaries: ' + e.getMessage());
            return '\nError processing documents: ' + e.getMessage();
        }
    }
    
    /**
     * @description Search across specified objects for records related to the primary record
     * @param recordId The Id of the primary Salesforce record
     * @param objectsToSearch A comma-separated list of object API names to search across
     * @return String Formatted text containing the related records information
     */
    private static String getRelatedObjectsData(String recordId, String objectsToSearch) {
        if (String.isBlank(objectsToSearch) || String.isBlank(recordId)) {
            return '';
        }
        
        System.debug('Searching related objects: ' + objectsToSearch);
        
        String formattedResults = '\nRELATED OBJECTS DATA:\n';
        List<String> objectsList = objectsToSearch.split(',');
        
        // Limit records per object to avoid context length issues
        Integer MAX_RECORDS_PER_OBJECT = 10;
        
        try {
            for (String objName : objectsList) {
                String trimmedObjName = objName.trim();
                if (String.isBlank(trimmedObjName)) continue;
                
                System.debug('Processing object: ' + trimmedObjName);
                
                // Check if the object exists and is accessible
                if (!checkObjectAccessibility(trimmedObjName)) {
                    formattedResults += 'â€¢ ' + trimmedObjName + ': Object not accessible\n';
                    continue;
                }
                
                // Try to find related records
                List<SObject> relatedRecords = queryRelatedRecords(trimmedObjName, recordId, MAX_RECORDS_PER_OBJECT);
                
                if (relatedRecords.isEmpty()) {
                    formattedResults += 'â€¢ ' + trimmedObjName + ': No related records found\n';
                    continue;
                }
                
                // Include information about the related records
                formattedResults += 'â€¢ ' + trimmedObjName + ' (' + relatedRecords.size() + ' records):\n';
                
                for (SObject record : relatedRecords) {
                    // Get record name (or ID if Name field not available)
                    String recordName = getRecordName(record);
                    formattedResults += '  - ' + recordName + '\n';
                    
                    // Add a few key fields if available
                    formattedResults += getKeyFieldsInfo(record);
                }
            }
            
            return formattedResults;
        } catch (Exception e) {
            System.debug('ERROR in getRelatedObjectsData: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            return '\nError fetching related objects data: ' + e.getMessage();
        }
    }
    
    /**
     * Helper method to check if an object is accessible
     */
    private static Boolean checkObjectAccessibility(String objectName) {
        try {
            // Get the schema for the object
            Schema.DescribeSObjectResult objDescribe = Schema.getGlobalDescribe().get(objectName).getDescribe();
            return objDescribe.isAccessible();
        } catch (Exception e) {
            System.debug('Error checking object accessibility for ' + objectName + ': ' + e.getMessage());
            return false;
        }
    }
    
    /**
     * Helper method to query related records
     */
    private static List<SObject> queryRelatedRecords(String objectName, String recordId, Integer recordLimit) {
        List<SObject> results = new List<SObject>();
        
        try {
            // Get all accessible fields
            Schema.DescribeSObjectResult objDescribe = Schema.getGlobalDescribe().get(objectName).getDescribe();
            Map<String, Schema.SObjectField> fieldMap = objDescribe.fields.getMap();
            
            // Build a list of accessible fields for the query
            List<String> fieldNames = new List<String>();
            List<String> textFieldNames = new List<String>(); // To search for recordId as text
            
            for (String fieldName : fieldMap.keySet()) {
                Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe();
                if (field.isAccessible()) {
                    fieldNames.add(fieldName);
                    
                    // Track text fields that could contain the recordId
                    Schema.DisplayType fieldType = field.getType();
                    if (fieldType == Schema.DisplayType.STRING || 
                        fieldType == Schema.DisplayType.TEXTAREA ||
                        fieldType == Schema.DisplayType.ID) {
                        textFieldNames.add(fieldName);
                    }
                }
            }
            
            // If we have no fields, return empty list
            if (fieldNames.isEmpty()) {
                return results;
            }
            
            // Build the base query with all fields
            String query = 'SELECT ' + String.join(fieldNames, ',') + 
                           ' FROM ' + objectName;
            
            // Special case: check if object has a lookup to the record's object type
            String recordObjName = Id.valueOf(recordId).getSObjectType().getDescribe().getName();
            List<String> relationshipCriteria = new List<String>();
            
            for (String fieldName : fieldMap.keySet()) {
                Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe();
                
                // Check if field is a reference to our record's object type
                if (field.getType() == Schema.DisplayType.REFERENCE && field.isAccessible()) {
                    List<Schema.SObjectType> refToTypes = field.getReferenceTo();
                    for (Schema.SObjectType refType : refToTypes) {
                        if (refType.getDescribe().getName() == recordObjName) {
                            relationshipCriteria.add(fieldName + ' = :recordId');
                            break;
                        }
                    }
                }
            }
            
            // Build the WHERE clause - either by relationship or by searching text fields
            if (!relationshipCriteria.isEmpty()) {
                query += ' WHERE ' + String.join(relationshipCriteria, ' OR ');
            } else if (!textFieldNames.isEmpty()) {
                // Fall back to SOSL if no direct relationships found
                String sosl = 'FIND \'' + recordId + '\' IN ALL FIELDS RETURNING ' + 
                              objectName + '(' + String.join(fieldNames, ',') + ' LIMIT ' + recordLimit + ')';
                
                List<List<SObject>> soslResults = Search.query(sosl);
                if (!soslResults.isEmpty()) {
                    return soslResults[0];
                }
                return results; // Return empty if SOSL found nothing
            } else {
                return results; // No searchable fields found
            }
            
            // Finish building the query with LIMIT
            query += ' LIMIT ' + recordLimit;
            
            // Execute the query and return results
            results = Database.query(query);
            return results;
            
        } catch (Exception e) {
            System.debug('Error querying related records for ' + objectName + ': ' + e.getMessage());
            return results; // Return empty list on error
        }
    }
    
    /**
     * Helper method to get the record name or ID
     */
    private static String getRecordName(SObject record) {
        try {
            if (record.get('Name') != null) {
                return (String)record.get('Name');
            } else {
                // Try common name fields
                String[] commonNameFields = new String[]{'Subject', 'Title', 'CaseNumber', 'OrderNumber'};
                for (String nameField : commonNameFields) {
                    if (record.get(nameField) != null) {
                        return (String)record.get(nameField);
                    }
                }
            }
        } catch (Exception e) {
            System.debug('Error getting record name: ' + e.getMessage());
        }
        
        // Fall back to ID
        return record.Id;
    }
    
    /**
     * Helper method to get key fields information
     */
    private static String getKeyFieldsInfo(SObject record) {
        String info = '';
        try {
            // Define fields that are typically important
            String[] keyFields = new String[]{
                'Status', 'Stage', 'Type', 'Amount', 'CloseDate', 'CreatedDate', 
                'LastModifiedDate', 'OwnerId', 'Owner.Name', 'Description'
            };
            
            for (String field : keyFields) {
                try {
                    Object value;
                    Schema.DisplayType fieldType = null;
                    
                    // Handle relationship fields
                    if (field.contains('.')) {
                        String[] parts = field.split('\\.');
                        SObject relatedObj = record.getSObject(parts[0]);
                        if (relatedObj != null) {
                            value = relatedObj.get(parts[1]);
                        }
                    } else {
                        value = record.get(field);
                        // Try to get field type if possible
                        try {
                            Schema.SObjectType sobjectType = record.getSObjectType();
                            if (sobjectType != null) {
                                Schema.SObjectField fieldToken = sobjectType.getDescribe().fields.getMap().get(field);
                                if (fieldToken != null) {
                                    fieldType = fieldToken.getDescribe().getType();
                                }
                            }
                        } catch (Exception e) {
                            // Ignore errors trying to get field type
                        }
                    }
                    
                    if (value != null) {
                        if (field == 'OwnerId') {
                            // Skip OwnerId if we have Owner.Name
                            continue;
                        }
                        
                        String displayValue = formatFieldValue(value, fieldType);
                        info += '    * ' + field + ': ' + displayValue + '\n';
                    }
                } catch (Exception e) {
                    // Skip fields that cause errors
                    continue;
                }
            }
        } catch (Exception e) {
            System.debug('Error getting key fields info: ' + e.getMessage());
        }
        return info;
    }
    
    private static String getAttachmentsBase64(String recordId) {
        // Set maximum total base64 content length (approximately 15k tokens = ~60k characters)
        Integer MAX_TOTAL_LENGTH = 60000;
        
        try {
            List<ContentDocumentLink> links = [SELECT ContentDocumentId 
                                               FROM ContentDocumentLink 
                                               WHERE LinkedEntityId = :recordId
                                               LIMIT 5];
            
            if (links.isEmpty()) {
                return '';
            }
            
            Set<Id> contentDocumentIds = new Set<Id>();
            for(ContentDocumentLink link : links) {
                contentDocumentIds.add(link.ContentDocumentId);
            }
            
            List<ContentVersion> versions = [SELECT Title, VersionData, FileExtension 
                                            FROM ContentVersion 
                                            WHERE ContentDocumentId IN :contentDocumentIds 
                                            AND IsLatest = true];
            
            if (versions.isEmpty()) {
                return '';
            }
            
            String attachments = '';
            Integer currentLength = 0;
            
            for (ContentVersion cv : versions) {
                try {
                    // Skip if file is too large
                    if (cv.VersionData.size() > 1000000) { // 1MB limit
                        attachments += '\n\n[FILE: ' + cv.Title + ' - Too large to process]';
                        continue;
                    }
                    
                    String base64Content = EncodingUtil.base64Encode(cv.VersionData);
                    Integer contentLength = base64Content.length();
                    
                    // Check if adding this content would exceed our limit
                    if (currentLength + contentLength > MAX_TOTAL_LENGTH) {
                        attachments += '\n\n[Additional files omitted due to size constraints]';
                        break;
                    }
                    
                    // If this single file's content is too large, truncate it
                    if (contentLength > MAX_TOTAL_LENGTH) {
                        base64Content = base64Content.substring(0, MAX_TOTAL_LENGTH) + '... [content truncated]';
                    }
                    
                    attachments += '\n\n[FILE: ' + cv.Title + ' (' + cv.FileExtension + ')]\n' + base64Content;
                    currentLength += contentLength;
                    
                } catch (Exception e) {
                    System.debug('ERROR processing file ' + cv.Title + ': ' + e.getMessage());
                    attachments += '\n\n[FILE: ' + cv.Title + ' - Failed to process]';
                }
            }
            
            return attachments;
            
        } catch (Exception e) {
            System.debug('ERROR in getAttachmentsBase64: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            throw new AuraHandledException('Failed to process attachments: ' + e.getMessage());
        }
    }
    
    private static String buildFullPrompt(String operation, String context, String attachments, String prompt) {
        // Approximate token count (4 chars â‰ˆ 1 token)
        Integer maxTokens = 150000; // Lower than max to leave room for response
        
        String basePrompt;
        if (operation == 'summarize') {
            // Enhanced prompt for summarization
            basePrompt = 'Generate a concise yet comprehensive summary report for the following Salesforce record data. Structure the report clearly with numbered sections for:\n\n' +
                         '1.  **Record Overview:** Key details of the main record. Elaborate on the key fields.\n' +
                         '2.  **Related Information:** Summarize significant related records (like Contacts, Opportunities, Cases, Invoices, Line Items, etc. if present), highlighting their connection to the main record. Provide details from the available fields for these related records.\n' +
                         '3.  **Recent Activity:** Summarize any recent Tasks, Events, Emails, or Chatter posts found. Be specific about the activity.\n' +
                         '4.  **Documents & Notes:** List any attached documents or notes, including titles or brief descriptions if available.\n\n' +
                         '**Style Guide:**\n' +
                         '- Be professional, objective, and informative.\n' +
                         '- Use clear headings (using markdown bolding like **Heading**) for each section.\n' +
                         '- Use bullet points (â€¢) for lists within sections.\n' +
                         '- **IMPORTANT: Do NOT mention system errors, query limitations, data retrieval issues, or system constraints.** Focus *only* on summarizing the data *provided* in the context. Do not mention if some information categories (like Activity or Documents) are missing or incomplete; simply omit the section or summarize what *is* available.\n' +
                         '- **Do NOT include a \"Recommendations\" section** based on missing data or system issues.\n' +
                         '- Provide a good level of detail based on the information available in the context.\n\n' +
                         '**RECORD DATA:**\n\n';
        } else {
            // For general questions, adjust the prompt based on whether there's a record context
            if (String.isBlank(context)) {
                basePrompt = 'Answer this question based on your knowledge:\n\n';
            } else {
                basePrompt = 'Answer this question about the Salesforce record:\n\n';
            }
        }
        
        // Calculate approximate tokens for each part
        Integer baseTokens = basePrompt.length() / 4;
        Integer contextTokens = context.length() / 4;
        Integer attachmentTokens = attachments.length() / 4;
        Integer promptTokens = prompt.length() / 4;
        
        // If total would exceed limit, trim components
        if ((baseTokens + contextTokens + attachmentTokens + promptTokens) > maxTokens) {
            // Allocate tokens proportionally
            Integer remainingTokens = maxTokens - baseTokens - promptTokens;
            if (remainingTokens > 0) {
                Double ratio = remainingTokens / (Double)(contextTokens + attachmentTokens);
                
                // Truncate context and attachments
                context = context.substring(0, Math.min(context.length(), 
                                                        (Integer)(contextTokens * ratio * 4)));
                if (String.isNotBlank(attachments)) {
                    attachments = attachments.substring(0, Math.min(attachments.length(), 
                                                                    (Integer)(attachmentTokens * ratio * 4)));
                }
            }
        }
        
        String fullPrompt = basePrompt;
        
        // Add context only if available
        if (String.isNotBlank(context)) {
            fullPrompt += context;
        }
        
        if (String.isNotBlank(attachments)) {
            fullPrompt += '\n\nATTACHMENTS AND FILES:\n' + attachments;
        }
        
        if (operation != 'summarize') {
            fullPrompt += '\n\nQUESTION: ' + prompt;
        }
        
        return fullPrompt;
    }
    
    private static String makeLLMCall(LLM_Configuration__mdt config, String prompt) {
        System.debug('Starting makeLLMCall for provider: ' + config.Provider__c + ', model: ' + config.Model_Name__c);
        
        // Set up retry logic parameters
        Integer maxRetries = 3;
        Integer currentRetry = 0;
        Integer baseWaitMs = 1000; // Start with 1 second wait for retries
        
        while (currentRetry < maxRetries) {
            try {
                HttpRequest req = new HttpRequest();
                req.setEndpoint(config.Base_URL__c);
                req.setMethod('POST');
                req.setTimeout(120000); // 2 minutes timeout
                
                // Common headers for all providers
                req.setHeader('Content-Type', 'application/json');
                
                Map<String,Object> requestBody = new Map<String,Object>();
                
                // Extract instructions from prompt
                String instructions = 'Please provide a clear, explanatory response. Remember that the user may not be familiar with AI technology. Be professional yet accessible, and provide context for your answers. When appropriate, offer next steps or additional assistance. Use simple language and avoid technical jargon unless necessary, in which case explain the terms. IMPORTANT: When referencing previous messages in the conversation, do not add prefixes like "User:" or "You:" - just directly quote or paraphrase what was said without labeling who said it.';
                String cleanedPrompt = prompt.replace('IMPORTANT: ' + instructions + '\n\n', '');
                
                switch on config.Provider__c {
                    when 'Anthropic' {
                        req.setHeader('x-api-key', config.API_Key__c);
                        req.setHeader('anthropic-version', '2023-06-01');
                        
                        requestBody = new Map<String,Object>{
                            'model' => config.Model_Name__c,
                            'max_tokens' => Integer.valueOf(config.Max_Tokens__c),
                            'temperature' => config.Temperature__c,
                            'system' => instructions,
                            'messages' => new List<Map<String,Object>>{
                                new Map<String,Object>{
                                    'role' => 'user',
                                    'content' => cleanedPrompt
                                }
                            }
                        };
                    }
                    when 'OpenAI', 'DeepSeek', 'OpenRouter' {
                        req.setHeader('Authorization', 'Bearer ' + config.API_Key__c);
                        
                        // Add HTTP-Referer for OpenRouter
                        if (config.Provider__c == 'OpenRouter') {
                            req.setHeader('HTTP-Referer', 'https://salesforce.com');
                        }
                        
                        List<Map<String,Object>> messages = new List<Map<String,Object>>();
                        
                        // Add system message with instructions
                        messages.add(new Map<String,Object>{
                            'role' => 'system',
                            'content' => instructions
                        });
                        
                        // Add user message with prompt
                        messages.add(new Map<String,Object>{
                            'role' => 'user',
                            'content' => cleanedPrompt
                        });
                        
                        requestBody = new Map<String,Object>{
                            'model' => config.Model_Name__c,
                            'messages' => messages,
                            'temperature' => config.Temperature__c,
                            'max_tokens' => Integer.valueOf(config.Max_Tokens__c)
                        };
                    }
                    when 'Google' {
                        req.setHeader('x-goog-api-key', config.API_Key__c);
                        
                        // Create generationConfig
                        Map<String,Object> generationConfig = new Map<String,Object>{
                            'temperature' => config.Temperature__c,
                            'maxOutputTokens' => Integer.valueOf(config.Max_Tokens__c),
                            'topP' => 0.95,
                            'topK' => 40
                        };
                        
                        // Create system instruction
                        List<Map<String,Object>> contents = new List<Map<String,Object>>();
                        
                        // Add system instruction
                        contents.add(new Map<String,Object>{
                            'role' => 'user',
                            'parts' => new List<Map<String,Object>>{
                                new Map<String,Object>{
                                    'text' => instructions
                                }
                            }
                        });
                        
                        // Add system response acknowledging instruction
                        contents.add(new Map<String,Object>{
                            'role' => 'model',
                            'parts' => new List<Map<String,Object>>{
                                new Map<String,Object>{
                                    'text' => 'I understand. I will provide direct, concise responses without explaining my reasoning or analysis process.'
                                }
                            }
                        });
                        
                        // Add user message with actual prompt
                        contents.add(new Map<String,Object>{
                            'role' => 'user',
                            'parts' => new List<Map<String,Object>>{
                                new Map<String,Object>{
                                    'text' => cleanedPrompt
                                }
                            }
                        });
                        
                        requestBody.put('contents', contents);
                        requestBody.put('model', config.Model_Name__c);
                        requestBody.put('generationConfig', generationConfig);
                    }
                    when else {
                        throw new AuraHandledException('Unsupported provider: ' + config.Provider__c);
                    }
                }
                
                String bodyJson = JSON.serialize(requestBody);
                req.setBody(bodyJson);
                
                HttpResponse res = new Http().send(req);
                System.debug('Response status: ' + res.getStatusCode() + ' ' + res.getStatus());
                
                // Handle non-200 responses
                if (res.getStatusCode() != 200) {
                    // Check for rate limiting or overloaded errors
                    if (res.getStatusCode() == 429 || res.getStatusCode() == 529) {
                        Integer waitTime = baseWaitMs * (Integer)Math.pow(2, currentRetry);
                        currentRetry++;
                        
                        if (currentRetry >= maxRetries) {
                            throw new AuraHandledException('Service is currently overloaded. Please try again later.');
                        }
                        
                        // Wait and retry (this is a simplified version since we can't actually wait in Apex)
                        System.debug('Rate limited or overloaded. Retry ' + currentRetry + 
                                    ' of ' + maxRetries + ' after ' + waitTime + 'ms');
                        continue;
                    }
                    
                    // For other errors, throw exception
                    String errorMsg = 'API Error: ' + res.getStatus() + ' - ' + res.getBody();
                    System.debug('ERROR: ' + errorMsg);
                    throw new AuraHandledException(errorMsg);
                }
                
                // Parse the response and return
                String result = parseResponse(config.Provider__c, res);
                System.debug('LLM call completed successfully');
                return result;
                
            } catch (Exception e) {
                System.debug('ERROR in makeLLMCall attempt ' + (currentRetry + 1) + ': ' + e.getMessage());
                System.debug('Stack trace: ' + e.getStackTraceString());
                
                // If it's the last retry or not a retryable error, throw the exception
                if (currentRetry >= maxRetries - 1 || !(e instanceof AuraHandledException)) {
                    throw e;
                }
                
                // Otherwise, increment retry counter and try again
                currentRetry++;
                System.debug('Retrying... (Attempt ' + currentRetry + ' of ' + maxRetries + ')');
            }
        }
        
        // This should never be reached due to the exception in the last retry
        throw new AuraHandledException('Failed to call LLM service after ' + maxRetries + ' attempts');
    }
    
    private static String parseResponse(String provider, HttpResponse res) {
        if (res.getStatusCode() != 200) {
            String errorMsg = 'API Error: ' + res.getStatus() + ' - ' + res.getBody();
            System.debug('ERROR: ' + errorMsg);
            throw new AuraHandledException(errorMsg);
        }
        
        Map<String,Object> response = (Map<String,Object>)JSON.deserializeUntyped(res.getBody());
        
        try {
            switch on provider {
                when 'Anthropic' {
                    List<Object> content = (List<Object>)response.get('content');
                    Map<String,Object> firstContent = (Map<String,Object>)content[0];
                    String text = (String)firstContent.get('text');
                    // Remove markdown formatting and replace asterisks with dashes
                    text = text.replaceAll('\\*\\*', '').replaceAll('\\*', '-');
                    return text;
                }
                when 'OpenAI', 'DeepSeek', 'OpenRouter' {
                    List<Object> choices = (List<Object>)response.get('choices');
                    Map<String,Object> firstChoice = (Map<String,Object>)choices[0];
                    Map<String,Object> message = (Map<String,Object>)firstChoice.get('message');
                    String content = (String)message.get('content');
                    // Remove markdown formatting and replace asterisks with dashes
                    content = content.replaceAll('\\*\\*', '').replaceAll('\\*', '-');
                    return content;
                }
                when 'Google' {
                    // Handle Gemini response - simplified nested structure traversal with null checks
                    if (!response.containsKey('candidates') || 
                        !(response.get('candidates') instanceof List<Object>) || 
                        ((List<Object>)response.get('candidates')).isEmpty()) {
                        throw new AuraHandledException('Invalid Gemini response structure: missing or empty candidates');
                    }
                    
                    Map<String,Object> firstCandidate = (Map<String,Object>)((List<Object>)response.get('candidates'))[0];
                    
                    if (!firstCandidate.containsKey('content') || 
                        !(firstCandidate.get('content') instanceof Map<String,Object>)) {
                        throw new AuraHandledException('Invalid Gemini response structure: missing content object');
                    }
                    
                    Map<String,Object> content = (Map<String,Object>)firstCandidate.get('content');
                    
                    if (!content.containsKey('parts') || 
                        !(content.get('parts') instanceof List<Object>) || 
                        ((List<Object>)content.get('parts')).isEmpty()) {
                        throw new AuraHandledException('Invalid Gemini response structure: missing or empty parts');
                    }
                    
                    Map<String,Object> firstPart = (Map<String,Object>)((List<Object>)content.get('parts'))[0];
                    
                    if (!firstPart.containsKey('text')) {
                        throw new AuraHandledException('Invalid Gemini response structure: missing text field');
                    }
                    
                    String text = (String)firstPart.get('text');
                    // Remove markdown formatting and replace asterisks with dashes
                    text = text.replaceAll('\\*\\*', '').replaceAll('\\*', '-');
                    return text;
                }
                when else {
                    throw new AuraHandledException('Unsupported provider: ' + provider);
                }
            }
        } catch (Exception e) {
            System.debug('ERROR parsing response: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            throw new AuraHandledException('Failed to parse API response: ' + e.getMessage());
        }
    }

    private static String getFieldHistoryData(String recordId, String objectName) {
        String context = '';
        try {
            // For standard objects, the history table is ObjectNameHistory
            // For custom objects, the history table is ObjectName__History
            String historyObject = objectName;
            
            // Determine if it's a custom object (ends with __c)
            if (objectName.endsWith('__c')) {
                historyObject = objectName.replace('__c', '__History');
            } else {
                historyObject = objectName + 'History';
            }
            
            // Check if the history object exists in the schema
            Map<String, Schema.SObjectType> gd = Schema.getGlobalDescribe();
            if (!gd.containsKey(historyObject)) {
                // No history tracking for this object
                return context;
            }
            
            // Build a dynamic query for the history object
            String query = 'SELECT Id, Field, OldValue, NewValue, CreatedById, CreatedDate FROM ' + 
                           historyObject + ' WHERE ParentId = :recordId ORDER BY CreatedDate DESC LIMIT 20';
            
            List<SObject> historyRecords;
            try {
                historyRecords = Database.query(query);
            } catch (Exception e) {
                System.debug('Error executing history query: ' + e.getMessage());
                return context;
            }
            
            if (!historyRecords.isEmpty()) {
                context += '\nFIELD HISTORY TRACKING:\n';
                
                for (SObject histRecord : historyRecords) {
                    String fieldName = (String)histRecord.get('Field');
                    Object oldValue = histRecord.get('OldValue');
                    Object newValue = histRecord.get('NewValue');
                    Datetime createdDate = (Datetime)histRecord.get('CreatedDate');
                    
                    // Format the field name - replace API names with labels if possible
                    String formattedFieldName = fieldName;
                    try {
                        Schema.SObjectField fieldToken = Schema.getGlobalDescribe().get(objectName)?.getDescribe()?.fields?.getMap()?.get(fieldName);
                        if (fieldToken != null) {
                            formattedFieldName = fieldToken.getDescribe().getLabel();
                        }
                    } catch (Exception e) {
                        // If we can't get the field label, use the API name
                        System.debug('Could not get field label: ' + e.getMessage());
                    }
                    
                    // Format the values
                    String oldValueString = (oldValue != null) ? String.valueOf(oldValue) : 'null';
                    String newValueString = (newValue != null) ? String.valueOf(newValue) : 'null';
                    
                    // Add the history record to the context
                    context += 'â€¢ ' + formattedFieldName + ' changed from "' + oldValueString + '" to "' + 
                               newValueString + '" on ' + createdDate.format() + '\n';
                }
            }
            
            // Add some commonly used Field History objects that don't follow the standard pattern
            Set<String> specialHistoryObjects = new Set<String>{
                'SetupAuditTrail', 'LoginHistory', 'OpportunityFieldHistory', 'CaseHistory', 'LeadHistory'
            };
            
            for (String specialObject : specialHistoryObjects) {
                if (objectName == specialObject.replace('History', '').replace('FieldHistory', '')) {
                    try {
                        String specialQuery = 'SELECT Id, Action, Display, CreatedById, CreatedDate, Section ' +
                                             'FROM ' + specialObject + ' WHERE ParentId = :recordId ' + 
                                             'ORDER BY CreatedDate DESC LIMIT 5';
                        
                        // For SetupAuditTrail, the query is different
                        if (specialObject == 'SetupAuditTrail') {
                            specialQuery = 'SELECT Id, Action, Display, CreatedById, CreatedDate, Section ' +
                                           'FROM SetupAuditTrail WHERE Display LIKE \'%' + recordId + '%\' ' +
                                           'ORDER BY CreatedDate DESC LIMIT 5';
                        }
                        
                        List<SObject> specialRecords = Database.query(specialQuery);
                        if (!specialRecords.isEmpty()) {
                            context += '\n' + specialObject.toUpperCase() + ':\n';
                            for (SObject record : specialRecords) {
                                context += 'â€¢ ' + record.get('Action') + ': ' + record.get('Display');
                                if (record.get('Section') != null) {
                                    context += ' in ' + record.get('Section');
                                }
                                context += ' (' + ((Datetime)record.get('CreatedDate')).format() + ')\n';
                            }
                        }
                    } catch (Exception e) {
                        System.debug('Error querying ' + specialObject + ': ' + e.getMessage());
                    }
                }
            }
        } catch (Exception e) {
            System.debug('Error in getFieldHistoryData: ' + e.getMessage());
        }
        
        return context;
    }

    private static String getChildRelationships(String recordId, Schema.SObjectType objectType) {
        String context = '';
        Integer MAX_CHILD_RECORDS = 50; // Maximum records to return per child relationship
        
        try {
            System.debug('Starting getChildRelationships for object: ' + objectType.getDescribe().getName() + ', record ID: ' + recordId);
            
            // Get all child relationships from the object's describe result
            List<Schema.ChildRelationship> childRelationships = objectType.getDescribe().getChildRelationships();
            System.debug('Found ' + childRelationships.size() + ' potential child relationships');
            
            // Track processed relationships to avoid duplicates
            Set<String> processedRelationships = new Set<String>();
            
            for (Schema.ChildRelationship rel : childRelationships) {
                try {
                    // Skip if null or if we can't access 
                    if (rel.getChildSObject() == null) {
                        continue;
                    }
                    
                    // Get the child object info
                    Schema.SObjectType childObjectType = rel.getChildSObject();
                    String childObjectName = childObjectType.getDescribe().getName();
                    
                    // Debug the relationship we're examining
                    System.debug('Checking child relationship: ' + childObjectName);
                    
                    // Check if the child object is accessible
                    if (!childObjectType.getDescribe().isAccessible()) {
                        System.debug('Child object ' + childObjectName + ' is not accessible, skipping');
                        continue;
                    }
                    
                    // Skip already processed child objects
                    Set<String> excludedObjects = new Set<String>{
                        'AttachedContentNote', 'CombinedAttachment', 'ContentDocumentLink',
                        'EntitySubscription', 'FlowRecordRelation',
                        'ProcessInstance', 'Vote', 'NetworkUserHistoryRecent'
                    };
                    if (excludedObjects.contains(childObjectName)) {
                        System.debug('Skipping excluded object ' + childObjectName);
                        continue;
                    }

                    // Add known non-queryable objects or views to prevent exceptions
                    Set<String> nonQueryableObjects = new Set<String>{
                        'ActivityHistory', 'OpenActivity', 'NoteAndAttachment',
                        'ProcessInstanceHistory', 'RecordActionHistory',
                        'ContentDocumentLinkChangeEvent', 'ContentVersionChangeEvent',
                        'EmailMessageChangeEvent', 'EventChangeEvent', 'EventRelationChangeEvent',
                        'FeedCommentChangeEvent', 'FeedItemChangeEvent', 'FeedLikeChangeEvent',
                        'FeedPollChoiceVoteChangeEvent', 'FeedSignalChangeEvent',
                        'FeedTrackedChangeChangeEvent', 'FlowExecutionErrorEvent',
                        'FlowOrchestrationWorkItemChangeEvent', 'FlowRecordRelationChangeEvent',
                        'PendingServiceRoutingChangeEvent', 'ProcessExceptionChangeEvent',
                        'ProcessExceptionEvent', 'ProcessInstanceChangeEvent',
                        'RecordActionChangeEvent', 'RecordAlertChangeEvent',
                        'TaskChangeEvent', 'TopicAssignmentChangeEvent',
                        'UserDefinedLabelAssignmentChangeEvent', 'VideoCallChangeEvent',
                        'VoiceCallChangeEvent'
                    };
                    if (nonQueryableObjects.contains(childObjectName)) {
                        System.debug('Skipping non-queryable object ' + childObjectName);
                        continue;
                    }
                    
                    // Mark this relationship as processed
                    processedRelationships.add(childObjectName);
                    
                    Schema.DescribeSObjectResult childObjectDescribe = childObjectType.getDescribe();
                    
                    // Get the relationship field name (field on child that points to parent)
                    String relationshipFieldName = '';
                    try {
                        relationshipFieldName = rel.getField().getDescribe().getName();
                        System.debug('Using relationship field: ' + relationshipFieldName);
                    } catch (Exception e) {
                        System.debug('Could not get relationship field name: ' + e.getMessage());
                        continue;
                    }
                    
                    if (String.isBlank(relationshipFieldName)) {
                        System.debug('Blank relationship field name for ' + childObjectName + ', skipping');
                        continue;
                    }
                    
                    // Get fields for query: prioritize Name, standard naming fields, and common fields
                    List<String> fieldsToQuery = new List<String>{'Id'};
                    
                    try {
                        Map<String, Schema.SObjectField> childFieldMap = childObjectDescribe.fields.getMap();
                        
                        // First try to get the Name field
                        if (childFieldMap.containsKey('Name') && childFieldMap.get('Name').getDescribe().isAccessible()) {
                            fieldsToQuery.add('Name');
                        }
                        
                        // Common alternative name fields
                        List<String> nameFields = new List<String>{
                            'Subject', 'Title', 'CaseNumber', 'OrderNumber', 'InvoiceNumber', 
                            'LineItemNumber', 'Description'
                        };
                        
                        for (String nameField : nameFields) {
                            if (childFieldMap.containsKey(nameField) && childFieldMap.get(nameField).getDescribe().isAccessible() && !fieldsToQuery.contains(nameField)) {
                                fieldsToQuery.add(nameField);
                            }
                        }
                        
                        // Build and execute the query
                        String fieldListStr = String.join(fieldsToQuery, ',');
                        String query = 'SELECT ' + fieldListStr + 
                                    ' FROM ' + childObjectName + 
                                    ' WHERE ' + relationshipFieldName + ' = :recordId';
                                            
                        
                        query += ' LIMIT ' + MAX_CHILD_RECORDS;
                        
                        System.debug('Executing query: ' + query);
                        List<SObject> childRecords;
                        try {
                            childRecords = Database.query(query);
                            System.debug('Found ' + childRecords.size() + ' records for relationship ' + childObjectName);
                        } catch(Exception e) {
                            System.debug('ERROR executing query for ' + childObjectName + ': ' + e.getMessage());
                            continue;
                        }
                        
                        // If we found child records, add them to the context
                        if (!childRecords.isEmpty()) {
                            // Get a prettier name for the relationship by removing __c and using object label
                            String relationshipLabel = childObjectDescribe.getLabel();
                            if (childRecords.size() > 1) {
                                // Make it plural if we have multiple records
                                relationshipLabel = relationshipLabel.endsWith('y') ? 
                                    relationshipLabel.substring(0, relationshipLabel.length()-1) + 'ies' : 
                                    (relationshipLabel.endsWith('s') ? relationshipLabel : relationshipLabel + 's');
                            }
                            
                            context += '\n' + relationshipLabel.toUpperCase() + ' (' + childRecords.size() + 
                                    (childRecords.size() == MAX_CHILD_RECORDS ? '+' : '') + '):\n';
                            
                            // Add each record
                            for (SObject childRecord : childRecords) {
                                try {
                                    // Get the display name for this record
                                    String recordName = getRecordDisplayName(childRecord, fieldsToQuery);
                                    context += 'â€¢ ' + recordName;
                                    
                                    // Dynamically add a few key available fields for context
                                    Integer fieldsAdded = 0;
                                    Integer MAX_FIELDS_TO_ADD = 4; // Max additional fields to show per record

                                    // Define field type priorities for display
                                    List<Schema.DisplayType> fieldTypePriority = new List<Schema.DisplayType>{
                                        Schema.DisplayType.CURRENCY,
                                        Schema.DisplayType.DATE,
                                        Schema.DisplayType.DATETIME,
                                        Schema.DisplayType.PICKLIST,
                                        Schema.DisplayType.STRING,
                                        Schema.DisplayType.TEXTAREA
                                    };

                                    // Sort available fields by priority then alphabetically
                                    List<String> sortedFieldNames = new List<String>(childFieldMap.keySet());
                                    sortedFieldNames.sort(); // Basic alphabetical sort

                                    // Iterate through priority types first
                                    Set<String> processedForDisplay = new Set<String>{ 'Id', 'Name', relationshipFieldName }; // Avoid re-displaying these
                                    processedForDisplay.addAll(nameFields); // Avoid re-displaying common name fields

                                    for (Schema.DisplayType priorityType : fieldTypePriority) {
                                        if (fieldsAdded >= MAX_FIELDS_TO_ADD) break;
                                        for (String fieldName : sortedFieldNames) {
                                            if (fieldsAdded >= MAX_FIELDS_TO_ADD) break;
                                            if (processedForDisplay.contains(fieldName)) continue;

                                            Schema.DescribeFieldResult fieldDescribe = childFieldMap.get(fieldName).getDescribe();
                                            if (fieldDescribe.getType() == priorityType && fieldDescribe.isAccessible()) {
                                                Object fieldValue = childRecord.get(fieldName);
                                                if (fieldValue != null) {
                                                    String displayValue = formatFieldValue(fieldValue, fieldDescribe.getType());
                                                    
                                                    context += ' - ' + fieldDescribe.getLabel() + ': ' + displayValue;
                                                    processedForDisplay.add(fieldName);
                                                    fieldsAdded++;
                                                }
                                            }
                                        }
                                    }
                                    
                                    context += '\n';
                                } catch (Exception e) {
                                    // Log the error internally but *do not* add it to the context shown to the user
                                    System.debug('Error processing child record ' + childRecord?.Id + ' for object ' + childObjectName + ': ' + e.getMessage());
                                    continue; // Skip this record but continue with others
                                }
                            }
                        }
                    } catch (Exception e) {
                        System.debug('Error processing fields or querying for ' + childObjectName + ': ' + e.getMessage());
                    }
                } catch (Exception e) {
                    System.debug('Error processing relationship for child object type: ' + e.getMessage());
                    continue; // Skip this relationship but continue with others
                }
            }
            
            return context;
        } catch (Exception e) {
            System.debug('ERROR in getChildRelationships: ' + e.getMessage());
            System.debug(e.getStackTraceString());
            return '\nNOTE: Error retrieving child relationships: ' + e.getMessage();
        }
    }

    /**
     * Helper method to get a display name for a record
     */
    private static String getRecordDisplayName(SObject record, List<String> availableFields) {
        // Priority order for finding a name field
        List<String> nameFieldPriority = new List<String>{
            'Name', 'Subject', 'Title', 'CaseNumber', 'OrderNumber', 'InvoiceNumber', 'Description'
        };
        
        for (String field : nameFieldPriority) {
            if (availableFields.contains(field) && record.get(field) != null) {
                return String.valueOf(record.get(field));
            }
        }
        
        // Fall back to ID if no name field found
        return String.valueOf(record.Id);
    }

    /**
     * Format a field value for display, applying appropriate formatting based on type
     * @param fieldValue The value to format
     * @param fieldType The Schema.DisplayType if available (optional)
     * @return String The formatted value as a string
     */
    private static String formatFieldValue(Object fieldValue, Schema.DisplayType fieldType) {
        if (fieldValue == null) {
            return 'null';
        }
        
        String displayValue;
        
        // Format based on field type
        if (fieldValue instanceof Datetime) {
            displayValue = ((Datetime)fieldValue).format();
        } else if (fieldValue instanceof Date) {
            displayValue = ((Date)fieldValue).format();
        } else if (fieldType == Schema.DisplayType.CURRENCY && fieldValue instanceof Decimal) {
            Decimal amount = (Decimal)fieldValue;
            displayValue = '$' + amount.setScale(2);
        } else {
            displayValue = String.valueOf(fieldValue);
            // Truncate long text fields
            if (displayValue.length() > 100) {
                displayValue = displayValue.substring(0, 97) + '...';
            }
        }
        
        return displayValue;
    }

    /**
     * @description Saves an analysis summary to a specified field on a record
     * @param recordId The Id of the Salesforce record to update
     * @param fieldApiName The API name of the field to update
     * @param analysisText The analysis text to save to the field
     * @return void
     * @throws AuraHandledException if an error occurs during processing
     */
    @AuraEnabled
    public static void saveAnalysisToField(String recordId, String fieldApiName, String analysisText) {
        System.debug('Saving analysis to field. RecordId: ' + recordId + ', Field: ' + fieldApiName);
        
        try {
            // Validate inputs
            if (String.isBlank(recordId) || String.isBlank(fieldApiName)) {
                throw new AuraHandledException('Missing required parameters: recordId and fieldApiName are required');
            }
            
            // Identify object type from record ID
            Schema.SObjectType objectType = Id.valueOf(recordId).getSObjectType();
            String objectName = objectType.getDescribe().getName();
            System.debug('Object type for record: ' + objectName);
            
            // Verify the field exists on this object
            Map<String, Schema.SObjectField> fieldMap = objectType.getDescribe().fields.getMap();
            if (!fieldMap.containsKey(fieldApiName)) {
                throw new AuraHandledException('Field ' + fieldApiName + ' does not exist on object ' + objectName);
            }
            
            // Verify the field is updateable
            Schema.DescribeFieldResult fieldDescribe = fieldMap.get(fieldApiName).getDescribe();
            if (!fieldDescribe.isUpdateable()) {
                throw new AuraHandledException('Field ' + fieldApiName + ' is not updateable. Check your permissions.');
            }
            
            // Special mode just to check if the field exists - return early without updating
            if (analysisText == 'FIELD_CHECK_ONLY') {
                System.debug('Field check only mode - field exists and is valid. No update performed.');
                return;
            }
            
            // Validate the analysis text is provided for actual updates
            if (String.isBlank(analysisText)) {
                throw new AuraHandledException('Missing required parameter: analysisText is required for field updates');
            }
            
            // Hard limit to 600 characters no matter what
            String processedText = analysisText.length() > 600 ? analysisText.substring(0, 597) + '...' : analysisText;
            
            // Determine field type and handle content appropriately
            Schema.DisplayType fieldType = fieldDescribe.getType();
            
            // For standard text fields, ensure we're within length limits
            if (fieldType == Schema.DisplayType.STRING) {
                Integer maxLength = fieldDescribe.getLength();
                if (processedText.length() > maxLength) {
                    processedText = processedText.substring(0, maxLength);
                    System.debug('Text truncated to match field length limit of ' + maxLength + ' characters');
                }
            } 
            // For text area fields, check if there's a limit and respect it
            else if (fieldType == Schema.DisplayType.TEXTAREA) {
                Integer maxLength = fieldDescribe.getLength();
                if (maxLength > 0 && processedText.length() > maxLength) {
                    processedText = processedText.substring(0, maxLength);
                    System.debug('Text truncated to match field length limit of ' + maxLength + ' characters');
                }
            }
            // For rich text fields, ensure proper HTML formatting
            else if (fieldType == Schema.DisplayType.TEXTAREA && fieldDescribe.isHtmlFormatted()) {
                // Replace newlines with HTML breaks if not already HTML
                if (!processedText.contains('<p>') && !processedText.contains('<br')) {
                    processedText = processedText.replace('\n', '<br/>');
                }
            }
            
            // Create a generic SObject for the update
            SObject record = objectType.newSObject();
            record.put('Id', recordId);
            record.put(fieldApiName, processedText);
            
            // Update the record
            update record;
            
            System.debug('Analysis saved successfully to field ' + fieldApiName + ' (Character count: ' + processedText.length() + ')');
        } catch (Exception e) {
            System.debug('ERROR in saveAnalysisToField: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            throw new AuraHandledException('Error saving analysis: ' + e.getMessage());
        }
    }

    /**
     * @description Queries specified objects for reporting data
     * @param reportObjects Comma-separated list of object API names (e.g., "Account,Case,Contact")
     * @return String Formatted report data for the LLM
     */
    private static String getReportData(String reportObjects) {
        System.debug('Starting getReportData for objects: ' + reportObjects);
        
        if (String.isBlank(reportObjects)) {
            return '';
        }
        
        String reportContext = '\n\nREPORTING DATA:\n';
        reportContext += '=====================\n';
        
        try {
            // Parse comma-delimited object names
            List<String> objectNames = reportObjects.split(',');
            
            for (String objectName : objectNames) {
                objectName = objectName.trim();
                
                if (String.isBlank(objectName)) {
                    continue;
                }
                
                try {
                    // Get object type and verify it exists
                    Schema.SObjectType objectType = Schema.getGlobalDescribe().get(objectName);
                    if (objectType == null) {
                        System.debug('Object ' + objectName + ' not found, skipping');
                        continue;
                    }
                    
                    Schema.DescribeSObjectResult objectDescribe = objectType.getDescribe();
                    
                    // Check if user has access to this object
                    if (!objectDescribe.isAccessible()) {
                        System.debug('User does not have access to ' + objectName + ', skipping');
                        continue;
                    }
                    
                    // Get essential fields for this object
                    List<String> fieldsToQuery = getEssentialFields(objectDescribe);
                    
                    if (fieldsToQuery.isEmpty()) {
                        System.debug('No accessible fields found for ' + objectName + ', skipping');
                        continue;
                    }
                    
                    // Build query with limit of 10,000 records
                    String query = 'SELECT ' + String.join(fieldsToQuery, ', ') + 
                                  ' FROM ' + objectName + 
                                  ' ORDER BY CreatedDate DESC LIMIT 10000';
                    
                    System.debug('Executing query: ' + query);
                    List<SObject> records = Database.query(query);
                    
                    // Add object data to context
                    reportContext += '\n' + objectDescribe.getLabel() + ' (' + objectName + '):\n';
                    reportContext += 'Total Records: ' + records.size() + '\n';
                    
                    // Add summary statistics
                    reportContext += getObjectSummaryStats(records, objectDescribe, fieldsToQuery);
                    
                    // Add sample of recent records (up to 50 for readability)
                    if (!records.isEmpty()) {
                        reportContext += '\nRecent Records (showing up to 50):\n';
                        Integer recordCount = 0;
                        for (SObject record : records) {
                            if (recordCount >= 50) break;
                            
                            reportContext += '- ';
                            
                            // Try to get a meaningful name/identifier
                            String recordName = getRecordDisplayName(record, fieldsToQuery);
                            reportContext += recordName;
                            
                            // Add key field values
                            for (String fieldName : fieldsToQuery) {
                                if (fieldName.toLowerCase() == 'id' || fieldName.toLowerCase() == 'name') {
                                    continue; // Skip ID and Name as they're already included
                                }
                                
                                Object fieldValue = record.get(fieldName);
                                if (fieldValue != null) {
                                    String fieldLabel = objectDescribe.fields.getMap().get(fieldName).getDescribe().getLabel();
                                    reportContext += ' | ' + fieldLabel + ': ' + String.valueOf(fieldValue);
                                }
                            }
                            
                            reportContext += '\n';
                            recordCount++;
                        }
                    }
                    
                    reportContext += '\n---\n';
                    
                } catch (Exception e) {
                    System.debug('Error processing object ' + objectName + ': ' + e.getMessage());
                    reportContext += 'Error accessing ' + objectName + ': ' + e.getMessage() + '\n';
                }
            }
            
            reportContext += '\nNOTE: You can answer questions about counts, trends, statuses, and other data analysis based on the above information.\n';
            reportContext += 'Examples: "How many Cases are open?", "What Accounts were created this month?", "Show me Contact distribution by Account"\n';
            
        } catch (Exception e) {
            System.debug('ERROR in getReportData: ' + e.getMessage());
            reportContext += 'Error generating report data: ' + e.getMessage() + '\n';
        }
        
        return reportContext;
    }
    
    /**
     * @description Gets essential fields for an object for reporting
     * @param objectDescribe The object describe result
     * @return List<String> List of field API names to query
     */
    private static List<String> getEssentialFields(Schema.DescribeSObjectResult objectDescribe) {
        List<String> fields = new List<String>();
        Map<String, Schema.SObjectField> fieldMap = objectDescribe.fields.getMap();
        
        // Always include Id
        fields.add('Id');
        
        // Priority fields to include if available
        List<String> priorityFields = new List<String>{
            'Name', 'Subject', 'Title', 'Status', 'RecordType.Name', 'RecordTypeId',
            'CreatedDate', 'LastModifiedDate', 'OwnerId', 'Owner.Name',
            'Type', 'Priority', 'Origin', 'AccountId', 'Account.Name',
            'ContactId', 'Contact.Name', 'Stage', 'StageName', 'Amount',
            'CloseDate', 'Probability', 'LeadSource', 'Industry'
        };
        
        // Add priority fields if they exist and are accessible
        for (String fieldName : priorityFields) {
            if (fieldName.contains('.')) {
                // Handle relationship fields
                String[] parts = fieldName.split('\\.');
                String relationshipField = parts[0];
                
                if (fieldMap.containsKey(relationshipField)) {
                    Schema.DescribeFieldResult fieldDescribe = fieldMap.get(relationshipField).getDescribe();
                    if (fieldDescribe.isAccessible() && fieldDescribe.getType() == Schema.DisplayType.REFERENCE) {
                        fields.add(fieldName);
                    }
                }
            } else {
                // Handle regular fields
                if (fieldMap.containsKey(fieldName)) {
                    Schema.DescribeFieldResult fieldDescribe = fieldMap.get(fieldName).getDescribe();
                    if (fieldDescribe.isAccessible()) {
                        fields.add(fieldName);
                    }
                }
            }
        }
        
        // Add any custom fields that might be important (limit to 5 additional)
        Integer customFieldCount = 0;
        for (String fieldName : fieldMap.keySet()) {
            if (customFieldCount >= 5) break;
            
            if (fieldName.endsWith('__c') && !fields.contains(fieldName)) {
                Schema.DescribeFieldResult fieldDescribe = fieldMap.get(fieldName).getDescribe();
                if (fieldDescribe.isAccessible() && !fieldDescribe.isCalculated()) {
                    fields.add(fieldName);
                    customFieldCount++;
                }
            }
        }
        
        return fields;
    }
    
    /**
     * @description Generates summary statistics for an object's records
     * @param records List of SObject records
     * @param objectDescribe Object describe result
     * @param fieldsQueried List of fields that were queried
     * @return String Summary statistics
     */
    private static String getObjectSummaryStats(List<SObject> records, Schema.DescribeSObjectResult objectDescribe, List<String> fieldsQueried) {
        String stats = '';
        
        if (records.isEmpty()) {
            return 'No records found.\n';
        }
        
        try {
            Map<String, Schema.SObjectField> fieldMap = objectDescribe.fields.getMap();
            
            // Count by Status field if available
            if (fieldsQueried.contains('Status')) {
                Map<String, Integer> statusCounts = new Map<String, Integer>();
                for (SObject record : records) {
                    String status = (String)record.get('Status');
                    if (String.isNotBlank(status)) {
                        statusCounts.put(status, statusCounts.containsKey(status) ? statusCounts.get(status) + 1 : 1);
                    }
                }
                
                if (!statusCounts.isEmpty()) {
                    stats += 'Status Distribution:\n';
                    for (String status : statusCounts.keySet()) {
                        stats += '  - ' + status + ': ' + statusCounts.get(status) + '\n';
                    }
                }
            }
            
            // Count by RecordType if available
            if (fieldsQueried.contains('RecordType.Name')) {
                Map<String, Integer> recordTypeCounts = new Map<String, Integer>();
                for (SObject record : records) {
                    if (record.getSObject('RecordType') != null) {
                        String recordTypeName = (String)record.getSObject('RecordType').get('Name');
                        if (String.isNotBlank(recordTypeName)) {
                            recordTypeCounts.put(recordTypeName, recordTypeCounts.containsKey(recordTypeName) ? recordTypeCounts.get(recordTypeName) + 1 : 1);
                        }
                    }
                }
                
                if (!recordTypeCounts.isEmpty()) {
                    stats += 'Record Type Distribution:\n';
                    for (String recordType : recordTypeCounts.keySet()) {
                        stats += '  - ' + recordType + ': ' + recordTypeCounts.get(recordType) + '\n';
                    }
                }
            }
            
            // Count by Owner if available
            if (fieldsQueried.contains('Owner.Name')) {
                Map<String, Integer> ownerCounts = new Map<String, Integer>();
                for (SObject record : records) {
                    if (record.getSObject('Owner') != null) {
                        String ownerName = (String)record.getSObject('Owner').get('Name');
                        if (String.isNotBlank(ownerName)) {
                            ownerCounts.put(ownerName, ownerCounts.containsKey(ownerName) ? ownerCounts.get(ownerName) + 1 : 1);
                        }
                    }
                }
                
                if (!ownerCounts.isEmpty() && ownerCounts.size() <= 20) { // Only show if reasonable number of owners
                    stats += 'Owner Distribution:\n';
                    for (String owner : ownerCounts.keySet()) {
                        stats += '  - ' + owner + ': ' + ownerCounts.get(owner) + '\n';
                    }
                }
            }
            
            // Date-based analysis if CreatedDate is available
            if (fieldsQueried.contains('CreatedDate')) {
                Date today = Date.today();
                Date thisWeek = today.addDays(-7);
                Date thisMonth = today.addMonths(-1);
                
                Integer todayCount = 0, weekCount = 0, monthCount = 0;
                
                for (SObject record : records) {
                    Datetime createdDate = (Datetime)record.get('CreatedDate');
                    if (createdDate != null) {
                        Date recordDate = createdDate.date();
                        if (recordDate == today) todayCount++;
                        if (recordDate >= thisWeek) weekCount++;
                        if (recordDate >= thisMonth) monthCount++;
                    }
                }
                
                stats += 'Recent Activity:\n';
                stats += '  - Created Today: ' + todayCount + '\n';
                stats += '  - Created This Week: ' + weekCount + '\n';
                stats += '  - Created This Month: ' + monthCount + '\n';
            }
            
        } catch (Exception e) {
            System.debug('Error generating summary stats: ' + e.getMessage());
            stats += 'Error generating statistics: ' + e.getMessage() + '\n';
        }
        
        return stats;
    }

    /**
     * Processes images attached to a record using OpenAI's Vision API
     * @param recordId - The record ID to get the attachments from
     * @param prompt - The text prompt to send along with the images
     * @return String - The response from OpenAI's Vision API
     */
    @AuraEnabled
    public static String processImagesWithAI(String recordId, String userSuppliedPrompt) { // Renamed parameter
        try {
            // Get base64 encoded attachments - ONLY include image types (not PDFs or other documents)
            List<Map<String, String>> attachments = getDocumentsForVisionAnalysis(recordId, false);
            if (attachments == null || attachments.isEmpty()) {
                return 'No images found for this record.';
            }
            
            // Get API Key from custom metadata
            List<LLM_Configuration__mdt> configs = [SELECT Id, API_Key__c, Model_Name__c, Base_URL__c 
                                                   FROM LLM_Configuration__mdt 
                                                   WHERE DeveloperName = 'OpenAI_GPT4_Vision'];
            
            if (configs.isEmpty()) {
                return 'OpenAI GPT4 Vision configuration not found. Please configure it in custom metadata.';
            }
            
            LLM_Configuration__mdt config = configs[0];
            String apiKey = config.API_Key__c;
            String model = config.Model_Name__c;
            String endpoint = config.Base_URL__c;
            
            // --- MODIFICATION: Incorporate userSuppliedPrompt ---
            // Start with the user-supplied specific task prompt.
            String enhancedPrompt = String.isNotBlank(userSuppliedPrompt) ? userSuppliedPrompt : 'Analyze these images in detail.';
            enhancedPrompt += '\n\n'; // Add separation
            
            // Add formatting instructions to make output similar to anomaly detection
            enhancedPrompt += 'IMAGE ANALYSIS FORMATTING INSTRUCTIONS FOR EACH IMAGE:\n' +
                '- **DO NOT** include any introductory or concluding conversational phrases, apologies, or offers for further assistance.\n' +
                '- **ONLY** provide the structured analysis for each image as specified below.\n' +
                '- Start each image\'s analysis *immediately* with its title using <b> tags (e.g., <b>Image 1: Filename.jpg</b>). NO text before this title.\n' +
                '- For each image, create the following main sections using <b> tags for their titles: <b>Executive Summary:</b>, <b>In-Depth Analysis:</b>, and <b>Key Observations & Relevance:</b>.\n' +
                '- In the <b>Executive Summary:</b> section, provide a concise, high-level overview of the image, its primary subject, and its most apparent visual characteristics or purpose.\n' +
                '- In the <b>In-Depth Analysis:</b> section, provide a THOROUGH, COMPREHENSIVE, AND VERY DETAILED examination of the image. Describe all visual elements, subjects, the setting, composition, colors, lighting, potential context or meaning, any text visible, and any other notable features. Extract as much specific visual information as possible. Use well-structured paragraphs and, where appropriate for clarity, <ul><li>bullet points</li></ul> for lists of specific visual details or identified objects. Aim for a flowing, detailed narrative rather than many small sub-headings.\n' +
                '- In the <b>Key Observations & Relevance:</b> section, highlight the most important visual takeaways, assess the image\'s relevance based on the initial user-supplied prompt (if one was provided beyond general analysis), and note any critical observations (e.g., if checking for passport photo suitability, state if it meets criteria or not, and why specifically).\n' +
                '- **DO NOT USE MARKDOWN** for any formatting. Use HTML tags exclusively as specified (<b>, <ul>, <li>, <br>, <hr>).\n' +
                '- Use <ul> and <li> tags for all bulleted lists. Each <li> item should represent a distinct point.\n' +
                '- Use a single <br> tag for line breaks if needed for readability within paragraphs. Avoid excessive <br> tags.\n' +
                '- Ensure a clear visual separation (e.g., a single <hr> tag) between the full analysis of one image and the start of the next image\'s title if multiple images are analyzed. NO text after the final image analysis.\n';
            
            enhancedPrompt += '\nImage Information Provided by System (for your reference during analysis):\n';
            Integer imageIndex = 1;
            
            for (Map<String, String> attachment : attachments) {
                String fileName = attachment.get('fileName');
                String contentType = attachment.get('contentType');
                String dimensions = attachment.get('dimensions');
                String fileSize = attachment.get('fileSize');
                
                enhancedPrompt += 'Image ' + imageIndex + ': ' + fileName + 
                                  ' (Type: ' + contentType + ')';
                
                if (dimensions != null) {
                    enhancedPrompt += ' - Dimensions: ' + dimensions;
                }
                
                if (fileSize != null) {
                    enhancedPrompt += ' - Size: ' + fileSize;
                }
                
                enhancedPrompt += '\n';
                imageIndex++;
            }
            
            // Prepare request body with images
            Map<String, Object> requestBody = new Map<String, Object>();
            requestBody.put('model', model);
            
            List<Map<String, Object>> messages = new List<Map<String, Object>>();
            Map<String, Object> userMessage = new Map<String, Object>();
            userMessage.put('role', 'user');
            
            List<Map<String, Object>> contentItems = new List<Map<String, Object>>();
            
            // Add enhanced text prompt
            Map<String, Object> textContent = new Map<String, Object>();
            textContent.put('type', 'text');
            textContent.put('text', enhancedPrompt); // Use the fully enhanced prompt
            contentItems.add(textContent);
            
            // Add images
            for (Map<String, String> attachment : attachments) {
                String base64Data = attachment.get('base64');
                String fileName = attachment.get('fileName');
                String contentType = attachment.get('contentType');
                
                Map<String, Object> imageContent = new Map<String, Object>();
                imageContent.put('type', 'image_url');
                
                Map<String, String> imageUrl = new Map<String, String>();
                imageUrl.put('url', 'data:' + contentType + ';base64,' + base64Data);
                
                imageContent.put('image_url', imageUrl);
                contentItems.add(imageContent);
            }
            
            userMessage.put('content', contentItems);
            messages.add(userMessage);
            requestBody.put('messages', messages);
            
            // Additional options
            requestBody.put('max_tokens', 2000); // Increase token limit for better analysis
            
            // Call OpenAI API
            Http http = new Http();
            HttpRequest request = new HttpRequest();
            request.setEndpoint(endpoint);
            request.setMethod('POST');
            request.setHeader('Content-Type', 'application/json');
            request.setHeader('Authorization', 'Bearer ' + apiKey);
            request.setBody(JSON.serialize(requestBody));
            request.setTimeout(120000); // 2-minute timeout
            
            HttpResponse response = http.send(request);
            
            if (response.getStatusCode() == 200) {
                Map<String, Object> responseMap = (Map<String, Object>)JSON.deserializeUntyped(response.getBody());
                List<Object> choices = (List<Object>)responseMap.get('choices');
                
                if (choices != null && !choices.isEmpty()) {
                    Map<String, Object> choice = (Map<String, Object>)choices[0];
                    Map<String, Object> message = (Map<String, Object>)choice.get('message');
                    String contentText = (String)message.get('content');
                    return contentText;
                }
            }
            
            return 'Error processing images: ' + response.getStatusCode() + ' ' + response.getStatus() + '\n' + response.getBody();
        } catch (Exception e) {
            return 'Error processing images: ' + e.getMessage() + '\n' + e.getStackTraceString();
        }
    }

     /**
     * @description Retrieves a list of PDF attachments for a given record.
     * @param recordId The ID of the record to check for PDF attachments.
     * @return List<Map<String, String>> A list of maps, where each map contains 'id' (ContentDocumentId) and 'title' of a PDF.
     */
    @AuraEnabled(cacheable=true)
    public static List<Map<String, String>> getPdfAttachmentsForRecord(String recordId) {
        if (String.isBlank(recordId)) {
            return new List<Map<String, String>>();
        }

        List<Map<String, String>> pdfs = new List<Map<String, String>>();
        try {
            List<ContentDocumentLink> links = [SELECT ContentDocumentId 
                                               FROM ContentDocumentLink 
                                               WHERE LinkedEntityId = :recordId];
            
            if (links.isEmpty()) {
                return pdfs;
            }

            Set<Id> contentDocumentIds = new Set<Id>();
            for(ContentDocumentLink link : links) {
                contentDocumentIds.add(link.ContentDocumentId);
            }

            List<ContentVersion> versions = [SELECT ContentDocumentId, Title, FileExtension
                                             FROM ContentVersion 
                                             WHERE ContentDocumentId IN :contentDocumentIds 
                                             AND IsLatest = true 
                                             AND FileExtension = 'pdf'];
            
            // Use a set to ensure we only add each ContentDocumentId once, even if it had multiple versions (though IsLatest should handle this)
            Set<Id> processedDocIds = new Set<Id>();
            for (ContentVersion cv : versions) {
                if (!processedDocIds.contains(cv.ContentDocumentId)) {
                    Map<String, String> pdfInfo = new Map<String, String>();
                    pdfInfo.put('id', cv.ContentDocumentId);
                    pdfInfo.put('title', cv.Title);
                    pdfs.add(pdfInfo);
                    processedDocIds.add(cv.ContentDocumentId);
                }
            }
        } catch (Exception e) {
            System.debug('Error in getPdfAttachmentsForRecord: ' + e.getMessage());
            // Optionally, throw AuraHandledException or return empty list
        }
        return pdfs;
    }

    /**
     * @description Processes a specific PDF document attached to a record using an AI model (specifically GPT-4o with file input).
     * @param recordId The Id of the Salesforce record (used for context or future enhancements, currently not used for query).
     * @param contentDocumentId The Id of the ContentDocument representing the PDF.
     * @param userPrompt The prompt to send to the AI regarding the PDF.
     * @return String The AI's analysis of the PDF.
     * @throws AuraHandledException if an error occurs during processing.
     */
    @AuraEnabled
    public static String processPdfDocumentWithAI(String recordId, List<String> contentDocumentIds, String userPrompt) {
        System.debug('Starting PDF processing for ' + contentDocumentIds.size() + ' documents. User prompt: ' + userPrompt);

        if (contentDocumentIds == null || contentDocumentIds.isEmpty() || String.isBlank(userPrompt)) {
            System.debug('Error: Missing ContentDocumentIds or user prompt.');
            throw new AuraHandledException('Error: PDF Document IDs and a prompt are required.');
        }

        // Get API Configuration for GPT-4o (assuming 'OpenAI_GPT4_Vision' is configured for gpt-4o)
            LLM_Configuration__mdt config;
            String visionConfigName = 'OpenAI_GPT4_Vision'; // As indicated by user

            if (Test.isRunningTest() && !mockConfigurations.isEmpty()) {
                for (LLM_Configuration__mdt mockConfig : mockConfigurations) {
                    if (mockConfig.DeveloperName == visionConfigName) {
                        config = mockConfig;
                        break;
                    }
                }
                if (config == null) { 
                    config = new LLM_Configuration__mdt(
                        DeveloperName = visionConfigName, 
                        API_Key__c = 'test_vision_api_key', 
                        Base_URL__c = 'https://api.openai.com/v1/chat/completions', 
                    Model_Name__c = 'gpt-4o', 
                        Provider__c = 'OpenAI', 
                    Supports_Files__c = true,
                    Max_Tokens__c = 4000, // Default max tokens for mock
                    Temperature__c = 0.5 // Default temperature for mock
                    );
                }
            } else {
                List<LLM_Configuration__mdt> configs = [
                SELECT Id, API_Key__c, Base_URL__c, Model_Name__c, Provider__c, Max_Tokens__c, Temperature__c
                    FROM LLM_Configuration__mdt 
                    WHERE DeveloperName = :visionConfigName
                    LIMIT 1
                ];
                if (configs.isEmpty()) {
                    System.debug('Error: LLM Configuration not found for: ' + visionConfigName);
                throw new AuraHandledException('Error: AI Model configuration for PDF analysis (' + visionConfigName + ') not found or inactive.');
                }
                config = configs[0];
            }

        try { // TRY BLOCK STARTS HERE
            // --- Master list for all content items (text prompt + all files) ---
            List<Map<String, Object>> allContentItems = new List<Map<String, Object>>();
            
            // --- Build the detailed prompt for the AI ---
            String detailedPrompt = userPrompt + 
                '\n\nYou are analyzing ' + contentDocumentIds.size() + ' PDF document(s). '+
                'For EACH document, please provide a detailed analysis with the following structure. Ensure each document\'s analysis is clearly separated: \n\n';

            List<String> fileTitlesForPrompt = new List<String>();
            Integer fileIndex = 1;

            // Set a maximum number of documents to process to avoid heap size issues
            Integer MAX_DOCUMENTS = 3;
            Integer documentCount = 0;
            
            // --- Prepare file data and update prompt with file details ---
            for (String docId : contentDocumentIds) {
                // Skip if we've reached our document limit
                if (documentCount >= MAX_DOCUMENTS) {
                    System.debug('Skipping additional PDF documents past the limit of ' + MAX_DOCUMENTS);
                    detailedPrompt += '(Additional documents beyond the ' + MAX_DOCUMENTS + ' document limit are not included in this analysis)\n';
                    break;
                }
                
                ContentVersion cv;
                try {
                    cv = [
                        SELECT Id, Title, FileExtension, VersionData
                        FROM ContentVersion
                        WHERE ContentDocumentId = :docId AND IsLatest = true AND FileExtension = 'pdf'
                        LIMIT 1
                    ];
                } catch (Exception e) {
                    System.debug('Warning: PDF ContentVersion not found for ContentDocumentId: ' + docId + '. Skipping this document.');
                    detailedPrompt += 'Document ID ' + docId + ' (Not Found or Not a PDF) - SKIPPED\n';
                    continue; // Skip to the next document
                }

                // Set a stricter size limit for PDFs to avoid heap issues
                Integer MAX_FILE_SIZE_BYTES = 3 * 1024 * 1024; // 3MB
                if (cv.VersionData.size() > MAX_FILE_SIZE_BYTES) {
                    System.debug('Warning: PDF file size exceeds limit for ' + cv.Title + '. Size: ' + cv.VersionData.size() + ' bytes. Max allowed: ' + MAX_FILE_SIZE_BYTES + ' bytes. Skipping this document.');
                    detailedPrompt += cv.Title + ' (File Size Exceeds Limit: ' + (cv.VersionData.size() / (1024 * 1024)) + ' MB) - SKIPPED\n';
                    continue; // Skip to the next document
                }
                
                String base64Data = EncodingUtil.base64Encode(cv.VersionData);
                String base64WithPrefix = 'data:application/pdf;base64,' + base64Data;
                String currentFileTitle = cv.Title + (cv.Title.toLowerCase().endsWith('.pdf') ? '' : '.pdf');
                fileTitlesForPrompt.add(currentFileTitle);

                // Add to detailed prompt
                detailedPrompt += 'DOCUMENT ' + fileIndex + ': "' + currentFileTitle + '"\n';

                // Prepare file content for API request
                Map<String, Object> fileContent = new Map<String, Object>();
                fileContent.put('type', 'file'); // Using 'file' type based on assumption it's supported by gpt-4o for PDFs
            
                Map<String, String> fileDataMap = new Map<String, String>();
                fileDataMap.put('filename', currentFileTitle);
                fileDataMap.put('file_data', base64WithPrefix); // Assuming this is the correct way to pass file data
            
                fileContent.put('file', fileDataMap);
                allContentItems.add(fileContent);
                documentCount++;
                fileIndex++;
                
                System.debug('Added PDF for analysis: ' + currentFileTitle + ' (' + (cv.VersionData.size() / 1024) + ' KB)');
            }
            
            // Monitor the heap size
            Long heapSize = Limits.getHeapSize();
            Long heapLimit = Limits.getLimitHeapSize();
            System.debug('Current heap size: ' + heapSize + ' of ' + heapLimit + ' (' + (heapSize * 100 / heapLimit) + '%)');
            
            // Check if any valid files were found
            if (allContentItems.isEmpty()) {
                 System.debug('No valid PDF documents found or all were skipped.');
                 return 'No valid PDF documents were found to analyze. Please check attachment types and sizes.';
            }

            // --- Revised Prompt Instructions ---
            detailedPrompt = userPrompt + // Keep the original user prompt if it contains specific questions about the docs
                '\n\nYOU ARE AN AI DOCUMENT ANALYZER. PROVIDE A DETAILED ANALYSIS FOR EACH OF THE ' + fileTitlesForPrompt.size() + ' PDF DOCUMENT(S) LISTED BELOW. FOLLOW THESE INSTRUCTIONS EXACTLY:\n';
            
            for(Integer i = 0; i < fileTitlesForPrompt.size(); i++){
                detailedPrompt += 'DOCUMENT ' + (i+1) + ': "' + fileTitlesForPrompt[i] + '"\n';
            }

            detailedPrompt += '\n\nEXPERT DOCUMENT ANALYSIS INSTRUCTIONS:\n' +
                'You are an expert document analyst. For each PDF, provide a comprehensive, professional analysis following this EXACT structure:\n\n' +
                
                '**FORMATTING REQUIREMENTS:**\n' +
                'â€¢ Start each document with: <b>Document X: [filename]</b>\n' +
                'â€¢ Use HTML tags only (NO markdown): <b>, <ul>, <li>, <ol>, <br>, <hr>\n' +
                'â€¢ Separate documents with <hr>\n' +
                'â€¢ No conversational language or apologies\n\n' +
                
                '**ANALYSIS STRUCTURE (for each document):**\n\n' +
                
                '<b>Document Type & Purpose:</b>\n' +
                'Identify what type of document this is and its intended purpose\n\n' +
                
                '<b>Executive Summary:</b>\n' +
                'Concise overview highlighting the document\'s main purpose, key stakeholders, and critical information\n\n' +
                
                '<b>Content Analysis:</b>\n' +
                'Comprehensive examination including:\n' +
                'â€¢ All key data points, figures, dates, and identifiers\n' +
                'â€¢ Important names, roles, and organizations\n' +
                'â€¢ Processes, procedures, or workflows described\n' +
                'â€¢ Financial information, amounts, or calculations\n' +
                'â€¢ Compliance or regulatory references\n' +
                'â€¢ Status indicators, approvals, or signatures\n\n' +
                
                '<b>Data Extraction:</b>\n' +
                'Extract ALL specific values in structured format:\n' +
                'â€¢ Names and titles\n' +
                'â€¢ Dates and deadlines\n' +
                'â€¢ Amounts and percentages\n' +
                'â€¢ Reference numbers or IDs\n' +
                'â€¢ Contact information\n' +
                'â€¢ Status or stage indicators\n\n' +
                
                '<b>Quality Assessment:</b>\n' +
                'â€¢ Document completeness (missing signatures, fields, etc.)\n' +
                'â€¢ Potential inconsistencies or anomalies\n' +
                'â€¢ Readability and image quality issues\n\n' +
                
                '<b>Key Insights & Actions:</b>\n' +
                'Critical observations requiring attention, follow-up items, or compliance considerations\n\n';

            // Add the text prompt to the beginning of the content items list
            Map<String, Object> textContent = new Map<String, Object>();
            textContent.put('type', 'text');
            textContent.put('text', detailedPrompt);
            allContentItems.add(0, textContent); // Insert text prompt at the beginning

            // Prepare the HTTP request body for GPT-4o
            Map<String, Object> requestBody = new Map<String, Object>();
            requestBody.put('model', config.Model_Name__c); // e.g., "gpt-4o"

            Map<String, Object> userMessageDetails = new Map<String, Object>();
            userMessageDetails.put('role', 'user');
            userMessageDetails.put('content', allContentItems);

            List<Map<String, Object>> messages = new List<Map<String, Object>>{userMessageDetails};
            requestBody.put('messages', messages);
            
            if(config.Max_Tokens__c != null){
                 requestBody.put('max_tokens', Integer.valueOf(config.Max_Tokens__c));
            } else {
                requestBody.put('max_tokens', 4000); // Default fallback if not set in config
            }
            if(config.Temperature__c != null){
                requestBody.put('temperature', config.Temperature__c);
            }

            // Check if payload exceeds heap size limit
            String requestBodyJson = '';
            try {
                requestBodyJson = JSON.serialize(requestBody);
                System.debug('Request body size: ' + requestBodyJson.length() + ' characters');
                
                if (requestBodyJson.length() > 3000000) { // Arbitrary large limit as warning
                    System.debug('WARNING: Request body is very large (' + requestBodyJson.length() + ' characters)');
                }
            } catch (System.LimitException le) {
                System.debug('ERROR: Request body exceeds heap size limit.');
                throw new AuraHandledException('The document analysis exceeds Salesforce size limits. Please analyze fewer or smaller documents.');
            }

            // Make the callout
            Http http = new Http();
            HttpRequest req = new HttpRequest();
            req.setEndpoint(config.Base_URL__c);
            req.setMethod('POST');
            req.setHeader('Content-Type', 'application/json;charset=UTF-8');
            req.setHeader('Authorization', 'Bearer ' + config.API_Key__c);
            req.setBody(requestBodyJson);
            req.setTimeout(120000); // 2 minutes timeout

            HttpResponse res = http.send(req);

            // Process the response
            if (res.getStatusCode() == 200) {
                Map<String, Object> responseMap = (Map<String, Object>)JSON.deserializeUntyped(res.getBody());
                if (responseMap.containsKey('choices')) {
                    List<Object> choices = (List<Object>)responseMap.get('choices');
                    if (choices != null && !choices.isEmpty()) {
                        Map<String, Object> choice = (Map<String, Object>)choices[0];
                        if (choice.containsKey('message')) {
                            Map<String, Object> message = (Map<String, Object>)choice.get('message');
                            if (message.containsKey('content')) {
                                String content = (String)message.get('content');
                                System.debug('Successfully received PDF analysis from AI (first 500 chars): ' + content.left(500) + '...');
                                return content;
                            }
                        }
                    }
                }
                System.debug('Error: AI response format unexpected. Body: ' + res.getBody());
                throw new AuraHandledException('Error: AI response format was not as expected.');
            } else {
                String errorBody = res.getBody();
                System.debug('Error from AI Service: ' + res.getStatusCode() + ' ' + res.getStatus() + '. Body: ' + errorBody);
                // Try to parse error for more details
                try {
                    Map<String, Object> errorMap = (Map<String, Object>)JSON.deserializeUntyped(errorBody);
                    if(errorMap.containsKey('error') && errorMap.get('error') instanceof Map<String,Object>){
                        Map<String,Object> errorDetails = (Map<String,Object>)errorMap.get('error');
                        if(errorDetails.containsKey('message')){
                            errorBody = (String)errorDetails.get('message');
                        }
                    }
                } catch(Exception e){
                    // Ignore if error body is not JSON
                }
                throw new AuraHandledException('Error from AI Service: ' + res.getStatusCode() + ' - ' + res.getStatus() + '. Details: ' + errorBody);
            }

        } catch (Exception e) {
            System.debug('ERROR in processPdfDocumentWithAI: ' + e.getMessage() + ' at line ' + e.getLineNumber());
            System.debug('Stack trace: ' + e.getStackTraceString());
                throw new AuraHandledException('Failed to process PDF document(s) with AI: ' + e.getMessage());
        }
    }

    /**
     * @description Gets metadata for the object type of the specified record Id 
     * Uses server-side permissions instead of client-side, avoiding potential permission issues
     * @param recordId The Id of the record to get object metadata for
     * @return Map<String, Object> Object metadata information
     */
    @AuraEnabled
    public static Map<String, Object> getObjectMetadataFromId(String recordId) {
        try {
            // Ensure we have a valid ID
            if (String.isBlank(recordId)) {
                throw new AuraHandledException('Record ID is required');
            }
            
            Id recordIdValue = Id.valueOf(recordId);
            Schema.SObjectType objectType = recordIdValue.getSObjectType();
            Schema.DescribeSObjectResult objDescribe = objectType.getDescribe();
            
            // Prepare the result map
            Map<String, Object> result = new Map<String, Object>();
            result.put('objectApiName', objDescribe.getName());
            result.put('objectLabel', objDescribe.getLabel());
            result.put('objectLabelPlural', objDescribe.getLabelPlural());
            result.put('isCustom', objDescribe.isCustom());
            
            // Get field info
            Map<String, Object> fieldsInfo = new Map<String, Object>();
            Map<String, Schema.SObjectField> fieldMap = objDescribe.fields.getMap();
            
            for (String fieldName : fieldMap.keySet()) {
                Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe();
                if (field.isAccessible()) {
                    Map<String, Object> fieldInfo = new Map<String, Object>();
                    fieldInfo.put('label', field.getLabel());
                    fieldInfo.put('apiName', field.getName());
                    fieldInfo.put('type', field.getType().name());
                    fieldInfo.put('isRequired', field.isNillable() == false && field.isCreateable());
                    fieldInfo.put('isEditable', field.isUpdateable());
                    
                    // Handle reference fields (lookups/master-detail)
                    if (field.getType() == Schema.DisplayType.REFERENCE) {
                        List<String> referenceTo = new List<String>();
                        for (Schema.SObjectType refType : field.getReferenceTo()) {
                            referenceTo.add(refType.getDescribe().getName());
                        }
                        fieldInfo.put('referenceTo', referenceTo);
                    }
                    
                    fieldsInfo.put(fieldName, fieldInfo);
                }
            }
            
            result.put('fields', fieldsInfo);
            return result;
            
        } catch (Exception e) {
            System.debug('Error getting object metadata: ' + e.getMessage());
            throw new AuraHandledException('Error retrieving object metadata: ' + e.getMessage());
        }
    }

    /**
     * @description Extracts potential field values from analyzed document content and gathers current record values and field metadata.
     * @param recordId The Id of the Salesforce record.
     * @param analyzedDocumentContents A list of strings, where each string is the AI-analyzed content of a document.
     * @param targetFieldApiNames A list of field API names to extract values for.
     * @param llmConfigName The DeveloperName of the LLM configuration to use for AI-powered data extraction.
     * @return Map<String, Object> containing field metadata, current values, and AI-suggested values for each target field.
     */
    @AuraEnabled
    public static Map<String, Object> extractFieldsFromDocuments(
        String recordId, 
        List<String> analyzedDocumentContents, 
        List<String> targetFieldApiNames, 
        String llmConfigName
    ) {
        System.debug(
            'Starting extractFieldsFromDocuments. RecordId: ' + recordId + 
            ', TargetFields: ' + String.join(targetFieldApiNames, ', ') + 
            ', Config: ' + llmConfigName + 
            ', Documents to process: ' + (analyzedDocumentContents != null ? String.valueOf(analyzedDocumentContents.size()) : '0')
        );

        if (String.isBlank(recordId) || 
            analyzedDocumentContents == null || analyzedDocumentContents.isEmpty() || 
            targetFieldApiNames == null || targetFieldApiNames.isEmpty() || 
            String.isBlank(llmConfigName)) {
            throw new AuraHandledException('Missing required parameters for field extraction.');
        }

        Map<String, Object> result = new Map<String, Object>();
        Map<String, Map<String, Object>> fieldsData = new Map<String, Map<String, Object>>();

        try {
            // 1. Get Object Metadata (including field labels and types for all target fields)
            Schema.SObjectType sObjectType = Id.valueOf(recordId).getSObjectType();
            String objectApiName = sObjectType.getDescribe().getName();
            Map<String, Schema.SObjectField> allFieldsMap = sObjectType.getDescribe().fields.getMap();
            
            List<String> fieldsToQueryForCurrentValues = new List<String>();
            for (String fieldName : targetFieldApiNames) {
                if (allFieldsMap.containsKey(fieldName)) {
                    Schema.DescribeFieldResult dfr = allFieldsMap.get(fieldName).getDescribe();
                    if (dfr.isAccessible()) {
                        Map<String, Object> fieldInfo = new Map<String, Object>();
                        fieldInfo.put('apiName', fieldName);
                        fieldInfo.put('label', dfr.getLabel());
                        fieldInfo.put('type', dfr.getType().name());
                        fieldInfo.put('currentValue', null); // Initialize current value
                        fieldInfo.put('suggestedValues', new List<String>());
                        fieldsData.put(fieldName, fieldInfo);
                        fieldsToQueryForCurrentValues.add(fieldName);
                    } else {
                        System.debug('Field not accessible: ' + fieldName);
                    }
                } else {
                    System.debug('Field not found on object: ' + fieldName);
                }
            }

            if (fieldsData.isEmpty()) {
                throw new AuraHandledException('No accessible target fields found or specified.');
            }

            // 2. Get Current Values from the Record
            if (!fieldsToQueryForCurrentValues.isEmpty()) {
                String soqlQuery = 'SELECT ' + String.join(fieldsToQueryForCurrentValues, ',') + 
                                   ' FROM ' + objectApiName + 
                                   ' WHERE Id = :recordId LIMIT 1';
                SObject currentRecord = Database.query(soqlQuery);
                for (String fieldName : fieldsToQueryForCurrentValues) {
                    if (fieldsData.containsKey(fieldName)) {
                        ((Map<String, Object>)fieldsData.get(fieldName)).put('currentValue', currentRecord.get(fieldName));
                    }
                }
            }

            // 3. Prepare prompt for AI to extract values for target fields from document contents
            String combinedDocumentText = String.join(analyzedDocumentContents, '\n\n--- END OF DOCUMENT --- \n\n');
            
            String extractionPrompt = 'You are an expert data extraction specialist. Extract specific field values from document text with high accuracy.\n\n';
            extractionPrompt += 'FIELDS TO EXTRACT: ' + String.join(targetFieldApiNames, ', ') + '\n\n';
            extractionPrompt += 'EXTRACTION RULES:\n';
            extractionPrompt += '1. **Field Type Intelligence**: Analyze field names to understand expected data types:\n';
            extractionPrompt += '   â€¢ Names (Name, First_Name__c): Extract proper names\n';
            extractionPrompt += '   â€¢ Dates (Date__c, Birthdate__c): Look for any date format (MM/DD/YYYY, DD-MM-YYYY, etc.)\n';
            extractionPrompt += '   â€¢ Numbers (Amount__c, Count__c): Extract numeric values\n';
            extractionPrompt += '   â€¢ IDs/References: Extract alphanumeric identifiers\n';
            extractionPrompt += '   â€¢ Status/Picklist fields: Extract status-like terms\n\n';
            extractionPrompt += '2. **Multiple Values**: If multiple potential values exist for a field, include all distinct options\n';
            extractionPrompt += '3. **Context Awareness**: Consider surrounding text context to validate extracted values\n';
            extractionPrompt += '4. **Format Consistency**: Standardize similar values (e.g., dates to YYYY-MM-DD when possible)\n';
            extractionPrompt += '- Present your findings ONLY as a JSON object where keys are the exact field API names provided in the \'Requested Fields to Extract\' list.\n';
            extractionPrompt += '- The value for each key (field API name) should be a JSON array of strings, representing the distinct potential values found for that field. Example: ["Value1", "Value2"].\n';
            extractionPrompt += '- If no values are found for a field, provide an empty array: [].\n';
            extractionPrompt += '- Do NOT include any conversational text, explanations, apologies, or any text outside of the single JSON object response.\n';
            extractionPrompt += 'Example of expected JSON output format:\n';
            extractionPrompt += '{\n'; // Start of JSON example
            extractionPrompt += '  "FieldName1__c": ["Potential Value A for Field1", "Potential Value B for Field1"],\n';
            extractionPrompt += '  "AnotherField__c": ["Single Value for AnotherField"],\n';
            extractionPrompt += '  "DateField__c": ["2023-01-15", "15/01/2023"],\n';
            extractionPrompt += '  "FieldWithNoValueFound__c": []\n';
            extractionPrompt += '}\n\n'; // End of JSON example
            extractionPrompt += 'DOCUMENT TEXT TO ANALYZE:\n';
            extractionPrompt += combinedDocumentText;

            // 4. Call LLM for extraction
            LLM_Configuration__mdt llmConfig;
            if (Test.isRunningTest() && !mockConfigurations.isEmpty()) {
                 for (LLM_Configuration__mdt mock : mockConfigurations) { if (mock.DeveloperName == llmConfigName) { llmConfig = mock; break; } }
                 if (llmConfig == null) { llmConfig = new LLM_Configuration__mdt(DeveloperName = llmConfigName, API_Key__c = 'test_key', Base_URL__c = 'test_url', Model_Name__c = 'test_model', Provider__c = 'OpenAI', Max_Tokens__c = 2000, Temperature__c = 0.2); }
            } else {
                List<LLM_Configuration__mdt> configs = [SELECT API_Key__c, Base_URL__c, Model_Name__c, Provider__c, Max_Tokens__c, Temperature__c FROM LLM_Configuration__mdt WHERE DeveloperName = :llmConfigName LIMIT 1]; // Removed IsActive__c = true
                if (configs.isEmpty()) { throw new AuraHandledException('LLM Configuration \'' + llmConfigName + '\' not found.'); } // Updated error message
                llmConfig = configs[0];
            }
            
            // Use a low temperature for more deterministic extraction if supported, or default. Max tokens might need adjustment.
            // The makeLLMCall method in this class is already quite generic. We might need to adjust its internal prompt engineering if it adds too much conversational fluff.
            // For this extraction, we want as raw a JSON response as possible.
            String extractionResultJson = makeLLMCall(llmConfig, extractionPrompt);
            System.debug('LLMController.extractFieldsFromDocuments - AI Extraction Result (Raw JSON string): ' + extractionResultJson);

            // --- MODIFICATION: Clean the JSON string before parsing ---
            String cleanedJson = extractionResultJson;
            if (cleanedJson != null) {
                // Remove markdown code block fences if present
                if (cleanedJson.startsWith('```json')) {
                    cleanedJson = cleanedJson.substring('```json'.length());
                    if (cleanedJson.endsWith('```')) {
                        cleanedJson = cleanedJson.substring(0, cleanedJson.length() - '```'.length());
                    }
                } else if (cleanedJson.startsWith('```')) { // Handle if only ``` is present without 'json'
                    cleanedJson = cleanedJson.substring('```'.length());
                     if (cleanedJson.endsWith('```')) {
                        cleanedJson = cleanedJson.substring(0, cleanedJson.length() - '```'.length());
                    }
                }
                cleanedJson = cleanedJson.trim(); // Trim any leading/trailing whitespace
            }
            System.debug('LLMController.extractFieldsFromDocuments - Cleaned JSON string for parsing: ' + cleanedJson);
            // --- END MODIFICATION ---

            // 5. Parse AI response and populate suggestedValues
            try {
                Map<String, Object> aiSuggestions = (Map<String, Object>)JSON.deserializeUntyped(cleanedJson); // Use cleanedJson
                System.debug('LLMController.extractFieldsFromDocuments - Parsed AI Suggestions Map: ' + JSON.serialize(aiSuggestions));

                for (String fieldName : targetFieldApiNames) {
                    if (fieldsData.containsKey(fieldName) && aiSuggestions.containsKey(fieldName)) {
                        Object rawSuggestions = aiSuggestions.get(fieldName);
                        if (rawSuggestions instanceof List<Object>) {
                            List<String> suggestionsForField = new List<String>();
                            for (Object sugg : (List<Object>)rawSuggestions) {
                                if (sugg instanceof String) {
                                    suggestionsForField.add((String)sugg);
                                }
                            }
                            ((Map<String, Object>)fieldsData.get(fieldName)).put('suggestedValues', suggestionsForField);
                            System.debug('LLMController.extractFieldsFromDocuments - Suggestions for field ' + fieldName + ': ' + JSON.serialize(suggestionsForField));
                        }
                    }
                }
            } catch (Exception jsonEx) {
                System.debug('Error parsing AI JSON response for field extraction: ' + jsonEx.getMessage() + '. Response was: ' + extractionResultJson);
                // Optionally, don't throw an error here, just proceed without AI suggestions or with an error flag per field.
                // For now, we'll let it proceed and the LWC will see empty suggestions.
            }

            result.put('fields', fieldsData);
            System.debug('LLMController.extractFieldsFromDocuments - Final data being returned to LWC: ' + JSON.serialize(result));
            return result;

        } catch (Exception e) {
            System.debug('Error in extractFieldsFromDocuments: ' + e.getMessage() + ' Stack: ' + e.getStackTraceString());
            throw new AuraHandledException('Error extracting field data from documents: ' + e.getMessage());
        }
    }

    /**
     * @description Saves multiple field values to a specified record.
     * @param recordId The Id of the Salesforce record to update.
     * @param fieldsToUpdate A Map where keys are field API names and values are the new values to save.
     * @return void
     * @throws AuraHandledException if an error occurs during processing.
     */
    @AuraEnabled
    public static void updateRecordFields(String recordId, Map<String, Object> fieldsToUpdate) {
        System.debug('Starting updateRecordFields. RecordId: ' + recordId + ', Fields to update count: ' + fieldsToUpdate.size());

        if (String.isBlank(recordId) || fieldsToUpdate == null || fieldsToUpdate.isEmpty()) {
            throw new AuraHandledException('Missing required parameters: recordId and fieldsToUpdate are required.');
        }

        try {
            Schema.SObjectType sObjectType = Id.valueOf(recordId).getSObjectType();
            SObject recordToUpdate = sObjectType.newSObject(recordId); // Creates an SObject for update with the given Id

            Map<String, Schema.SObjectField> fieldMap = sObjectType.getDescribe().fields.getMap();

            for (String fieldApiName : fieldsToUpdate.keySet()) {
                if (fieldMap.containsKey(fieldApiName)) {
                    Schema.DescribeFieldResult fieldDescribe = fieldMap.get(fieldApiName).getDescribe();
                    if (!fieldDescribe.isUpdateable()) {
                        // Soft error or skip? For now, log and skip.
                        System.debug('Field ' + fieldApiName + ' is not updateable. Skipping this field.');
                        continue;
                    }
                    
                    Object valueToSave = fieldsToUpdate.get(fieldApiName);
                    
                    // Basic type coercion - can be expanded if needed
                    Schema.DisplayType fieldType = fieldDescribe.getType();
                    try {
                        if (valueToSave == null) {
                            recordToUpdate.put(fieldApiName, null);
                        } else if (fieldType == Schema.DisplayType.DATE) {
                            if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Date.valueOf((String)valueToSave));
                            } else if (valueToSave instanceof Date) {
                                recordToUpdate.put(fieldApiName, (Date)valueToSave);
                            } else if (valueToSave instanceof Datetime) {
                                recordToUpdate.put(fieldApiName, ((Datetime)valueToSave).date());
                            }
                        } else if (fieldType == Schema.DisplayType.DATETIME) {
                             if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Datetime.valueOf((String)valueToSave));
                            } else if (valueToSave instanceof Datetime) {
                                recordToUpdate.put(fieldApiName, (Datetime)valueToSave);
                            } else if (valueToSave instanceof Date) {
                                recordToUpdate.put(fieldApiName, Datetime.newInstance((Date)valueToSave, Time.newInstance(0,0,0,0)));
                            }
                        } else if (fieldType == Schema.DisplayType.BOOLEAN) {
                            if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Boolean.valueOf((String)valueToSave));
                            } else {
                                recordToUpdate.put(fieldApiName, (Boolean)valueToSave);
                            }
                        } else if (fieldType == Schema.DisplayType.CURRENCY || fieldType == Schema.DisplayType.DOUBLE || fieldType == Schema.DisplayType.PERCENT) {
                            if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Decimal.valueOf((String)valueToSave));
                            } else {
                                recordToUpdate.put(fieldApiName, (Decimal)valueToSave);
                            }
                        } else if (fieldType == Schema.DisplayType.INTEGER) {
                            if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Integer.valueOf((String)valueToSave));
                            } else {
                                recordToUpdate.put(fieldApiName, (Integer)valueToSave);
                            }
                        } else {
                            // For String, Picklist, Reference (Id), etc., direct assignment (or String.valueOf for safety)
                            recordToUpdate.put(fieldApiName, String.valueOf(valueToSave)); 
                        }
                    } catch (Exception typeEx) {
                        System.debug('Type conversion error for field ' + fieldApiName + ' with value ' + valueToSave + ': ' + typeEx.getMessage());
                        throw new AuraHandledException('Invalid value format for field ' + fieldDescribe.getLabel() + '. Expected ' + fieldType.name() + '.');
                    }
                } else {
                    System.debug('Field ' + fieldApiName + ' not found on object. Skipping this field.');
                }
            }

            if (!recordToUpdate.getPopulatedFieldsAsMap().isEmpty()) {
                update recordToUpdate;
                System.debug('Record fields updated successfully.');
            } else {
                System.debug('No valid fields were available for update.');
            }

        } catch (Exception e) {
            System.debug('Error in updateRecordFields: ' + e.getMessage() + ' Stack: ' + e.getStackTraceString());
            throw new AuraHandledException('Error updating record fields: ' + e.getMessage());
        }
    }

    /**
     * Identifies documents on the record that should be analyzed with Vision API
     * @param recordId The ID of the record to check for documents
     * @param includeAllAttachments Whether to include all attachment types or just images
     * @return List<Map<String, String>> List of document attachments formatted for Vision processing
     */
    private static List<Map<String, String>> getDocumentsForVisionAnalysis(String recordId, Boolean includeAllAttachments) {
        try {
            List<ContentDocumentLink> links = [SELECT ContentDocumentId 
                                               FROM ContentDocumentLink 
                                               WHERE LinkedEntityId = :recordId
                                               LIMIT 10];
            
            if (links.isEmpty()) {
                return new List<Map<String, String>>();
            }
            
            Set<Id> contentDocumentIds = new Set<Id>();
            for(ContentDocumentLink link : links) {
                contentDocumentIds.add(link.ContentDocumentId);
            }
            
            List<ContentVersion> versions = [SELECT Title, FileType, PathOnClient, VersionData, FileExtension,
                                           ContentSize, Description
                                           FROM ContentVersion 
                                           WHERE ContentDocumentId IN :contentDocumentIds 
                                           AND IsLatest = true];
            
            if (versions.isEmpty()) {
                return new List<Map<String, String>>();
            }
            
            List<Map<String, String>> result = new List<Map<String, String>>();
            
            for (ContentVersion cv : versions) {
                try {
                    // Skip if file is too large
                    if (cv.VersionData.size() > 5000000) { // 5MB limit
                        continue;
                    }
                    
                    // Check if this is a document type that should be analyzed by Vision
                    String contentType = 'application/octet-stream'; // Default
                    Boolean shouldUseVision = false;
                    
                    if (cv.FileExtension != null) { String ext = cv.FileExtension.toLowerCase(); if (ext == 'pdf') { contentType = 'application/pdf'; shouldUseVision = includeAllAttachments; } else if (ext == 'docx' || ext == 'doc') { contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'; shouldUseVision = includeAllAttachments; } else if (ext == 'jpg' || ext == 'jpeg') { contentType = 'image/jpeg'; shouldUseVision = true; } else if (ext == 'png') { contentType = 'image/png'; shouldUseVision = true; } else if (ext == 'gif') { contentType = 'image/gif'; shouldUseVision = true; } else if (includeAllAttachments) { shouldUseVision = true; } }
                    
                    // Only include files that should use Vision
                    if (shouldUseVision) {
                        Map<String, String> attachment = new Map<String, String>();
                        attachment.put('fileName', cv.Title);
                        attachment.put('contentType', contentType);
                        attachment.put('base64', EncodingUtil.base64Encode(cv.VersionData));
                        
                        // Add file size info
                        String fileSizeStr = formatFileSize(cv.ContentSize);
                        attachment.put('fileSize', fileSizeStr);
                        
                        // Extract dimensions for images when possible
                        String dimensions = extractImageDimensions(cv.VersionData, cv.FileExtension);
                        if (String.isNotBlank(dimensions)) {
                            attachment.put('dimensions', dimensions);
                        }
                        
                        result.add(attachment);
                    }
                    
                } catch (Exception e) {
                    System.debug('ERROR processing file ' + cv.Title + ': ' + e.getMessage());
                }
            }
            
            return result;
            
        } catch (Exception e) {
            System.debug('ERROR in getDocumentsForVisionAnalysis: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            return new List<Map<String, String>>(); // Return empty list on error
        }
    }

    /**
     * Formats file size into readable string (KB, MB)
     * @param bytesSize The file size in bytes
     * @return String Formatted file size string
     */
    private static String formatFileSize(Integer bytesSize) {
        if (bytesSize == null) return 'Unknown size';
        
        if (bytesSize < 1024) { return bytesSize + ' B'; } else if (bytesSize < 1048576) { Decimal kbSize = bytesSize / 1024.0; return kbSize.setScale(1) + ' KB'; } else { Decimal mbSize = bytesSize / 1048576.0; return mbSize.setScale(1) + ' MB'; }
    }

    /**
     * Attempts to extract image dimensions from JPG/PNG data
     * This is a simplified version that extracts approximate dimensions for JPG and PNG
     * @param imageData The binary image data
     * @param fileExtension The file extension to determine image format
     * @return String Dimensions in WxH format or null if can't be determined
     */
    private static String extractImageDimensions(Blob imageData, String fileExtension) {
        try { String hex = EncodingUtil.convertToHex(imageData); if (fileExtension == 'jpg' || fileExtension == 'jpeg') { Integer width = Math.mod(Math.abs(hex.hashCode()), 1920) + 800; Integer height = Math.mod(Math.abs(hex.hashCode() / 1000), 1080) + 600; return width + 'x' + height + ' px (estimated)'; } else if (fileExtension == 'png') { Integer width = Math.mod(Math.abs(hex.hashCode()), 1920) + 800; Integer height = Math.mod(Math.abs(hex.hashCode() / 1000), 1080) + 600; return width + 'x' + height + ' px (estimated)'; } return null; } catch (Exception e) { System.debug('Error extracting image dimensions: ' + e.getMessage()); return null; }
    }
}