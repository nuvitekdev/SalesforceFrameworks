public with sharing class LLMController {
    /**
     * Mock configuration for testing purposes
     * This allows test classes to inject mock LLM configurations without database queries
     */
    @TestVisible
    private static List<LLM_Configuration__mdt> mockConfigurations = new List<LLM_Configuration__mdt>();
    
    @AuraEnabled(cacheable=true)
    public static List<LLM_Configuration__mdt> getLLMConfigurations() {
        System.debug('Getting LLM configurations');
        
        // In test context, use the mock configurations if available
        if (Test.isRunningTest() && !mockConfigurations.isEmpty()) {
            System.debug('Using mock configurations: ' + mockConfigurations.size());
            return mockConfigurations;
        }List<LLM_Configuration__mdt> configs = [SELECT Id, DeveloperName, MasterLabel, Provider__c, Model_Name__c, Supports_Files__c FROM LLM_Configuration__mdt WHERE IsActive__c = true];return configs;
    }
    
    @AuraEnabled
    public static String handleRequest(String recordId, String configName, String prompt, String operation, String relatedObjects) {
        System.debug('üöÄ Handle request started');
        System.debug('üìã Parameters - recordId: ' + recordId + ', configName: ' + configName + ', operation: ' + operation);
        System.debug('üîç configName is null: ' + (configName == null));
        System.debug('üîç configName length: ' + (String.isNotBlank(configName) ? configName.length() : 0));
        
        // Validate configName parameter
        if (String.isBlank(configName)) {
            System.debug('‚ùå ERROR: configName is blank or null');
            throw new AuraHandledException('Configuration name is required. Please select an AI model.');
        }
        
        try {
            // Use mock configurations in test context if available
            LLM_Configuration__mdt config;
            if (Test.isRunningTest() && !mockConfigurations.isEmpty()) {
                // Find matching mock config by name
                for (LLM_Configuration__mdt mockConfig : mockConfigurations) {
                    if (mockConfig.DeveloperName == configName) {
                        config = mockConfig;
                        break;
                    }
                }
                
                // If no matching mock config was found, create a default one
                if (config == null) { config = new LLM_Configuration__mdt(DeveloperName = configName, API_Key__c = 'test_api_key', Base_URL__c = 'https://test.example.com/api', Model_Name__c = 'test-model', Provider__c = 'TestProvider', Supports_Files__c = true, Max_Tokens__c = 2000, Temperature__c = 0.7); }} else {
                System.debug('üîç Querying LLM_Configuration__mdt with configName: ' + configName);
                
                // First, let's check what configurations are available
                List<LLM_Configuration__mdt> allConfigs = [SELECT DeveloperName, MasterLabel FROM LLM_Configuration__mdt];
                System.debug('üìã Available configurations: ' + allConfigs.size());
                for (LLM_Configuration__mdt cfg : allConfigs) {
                    System.debug('  - DeveloperName: ' + cfg.DeveloperName + ', MasterLabel: ' + cfg.MasterLabel);
                }
                
                // Now try to query the specific configuration
                List<LLM_Configuration__mdt> configList = [
                    SELECT API_Key__c, Base_URL__c, Model_Name__c, Provider__c, 
                           Supports_Files__c, Max_Tokens__c, Temperature__c 
                    FROM LLM_Configuration__mdt 
                    WHERE DeveloperName = :configName 
                    LIMIT 1
                ];
                
                if (configList.isEmpty()) {
                    System.debug('‚ùå ERROR: No configuration found for configName: ' + configName);
                    throw new AuraHandledException('No configuration found for model: ' + configName + '. Please ensure the model configuration exists and is active.');
                }
                
                config = configList[0];
                System.debug('‚úÖ Configuration loaded successfully');
            }
            
            String context = '';
            String attachments = '';
            String documentAnalysis = '';
            
            // Only get record context if a recordId is provided
            if (String.isNotBlank(recordId)) {
                context = getRecordContext(recordId, relatedObjects);
                
                // --- MODIFICATION FOR 'SUMMARIZE' OPERATION ---
                // For 'summarize' (Analyze Record), we do not perform deep analysis of document contents here.
                // Listing of attachments is handled within getRecordContext.
                // Dedicated buttons will handle deep PDF/Image analysis.
                if (!'summarize'.equalsIgnoreCase(operation)) {
                    // Check for PDFs and documents that would benefit from Vision analysis
                    // Include all attachment types for regular analysis
                    List<Map<String, String>> docAttachments = getDocumentsForVisionAnalysis(recordId, true);
                    if (!docAttachments.isEmpty()) {
                        System.debug('Found ' + docAttachments.size() + ' documents for Vision analysis');
                        
                        // Get Vision configuration
                        List<LLM_Configuration__mdt> visionConfigs;
                        
                        if (Test.isRunningTest() && !mockConfigurations.isEmpty()) {
                            // Find vision configuration in mocks
                            visionConfigs = new List<LLM_Configuration__mdt>();
                            for (LLM_Configuration__mdt mockConfig : mockConfigurations) {
                                if (mockConfig.DeveloperName == 'OpenAI_GPT4_Vision') {
                                    visionConfigs.add(mockConfig);
                                    break;
                                }
                            }
                            
                            // If no mock vision config was found, create a default one
                            if (visionConfigs.isEmpty()) { LLM_Configuration__mdt visionConfig = new LLM_Configuration__mdt(DeveloperName = 'OpenAI_GPT4_Vision', API_Key__c = 'test_vision_api_key', Base_URL__c = 'https://test.example.com/vision', Model_Name__c = 'test-vision-model', Provider__c = 'TestVisionProvider', Supports_Files__c = true); visionConfigs.add(visionConfig); }
                        } else {
                            visionConfigs = [SELECT Id, API_Key__c, Base_URL__c, Model_Name__c
                                             FROM LLM_Configuration__mdt 
                                             WHERE DeveloperName = 'OpenAI_GPT4_Vision' // Ensure active for consistency
                                             LIMIT 1];
                        }
                        
                        if (!visionConfigs.isEmpty()) {
                            // Process documents with Vision API
                            documentAnalysis = processDocumentsWithVision(docAttachments, visionConfigs[0], 
                                                                      'Analyze these documents in detail. Extract all important information.');
                        }
                    }
                    
                    // Get regular attachments text (this will exclude PDFs that were analyzed with Vision)
                    attachments = config.Supports_Files__c ? getAttachmentsText(recordId) : '';
                } else {
                    // Ensure these are empty for 'summarize' operation
                    documentAnalysis = '';
                    attachments = '';
                    System.debug('Summarize operation: Skipping deep document/attachment content analysis in handleRequest.');
                }
            }
            
            // Include document analysis in the prompt if available
            String fullPrompt = buildFullPrompt(operation, context, attachments, prompt);
            
            // Add document analysis results if available
            if (String.isNotBlank(documentAnalysis)) {
                fullPrompt += '\n\nDOCUMENT ANALYSIS (Processed with Vision AI):\n' + documentAnalysis;
            }
            
            System.debug('Full prompt length: ' + fullPrompt.length());
            
            return makeLLMCall(config, fullPrompt);
        } catch(Exception e) {
            System.debug('ERROR in handleRequest: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            throw new AuraHandledException('Error: ' + e.getMessage());
        }
    }
    
    /**
     * @description Checks a given record for potential anomalies, conflicts of interest, or inconsistencies using an AI model.
     * @param recordId The Id of the Salesforce record to analyze.
     * @param configName The DeveloperName of the LLM_Configuration__mdt to use.
     * @param relatedObjects Comma-separated list of object API names to search across for related data.
     * @param pdfDocumentIds List of ContentDocument Ids for PDF documents to include in the analysis
     * @param customPrompt Optional parameter containing a custom prompt to prepend to the default anomaly prompt
     * @return String The AI's assessment (e.g., "YES - Conflict of interest detected: Submitter and Investigator are the same." or "NO").
     * @throws AuraHandledException if an error occurs during processing.
     */
    @AuraEnabled
    public static String checkRecordForAnomalies(String recordId, String configName, String relatedObjects, 
                                              List<String> pdfDocumentIds, String customPrompt) {
        // Handle missing optional parameters
        pdfDocumentIds = pdfDocumentIds != null ? pdfDocumentIds : new List<String>();
        customPrompt = customPrompt != null ? customPrompt : '';
        
        System.debug('Anomaly check started for recordId: ' + recordId + ' using config: ' + configName);
        System.debug('PDF documents included: ' + (!pdfDocumentIds.isEmpty() ? pdfDocumentIds.size() + ' documents' : 'None'));
        System.debug('Custom prompt provided: ' + (String.isNotBlank(customPrompt) ? 'Yes' : 'No'));

        // Validate inputs
        if (String.isBlank(recordId) || String.isBlank(configName)) {
            System.debug('ERROR in checkRecordForAnomalies: Missing recordId or configName.');
            throw new AuraHandledException('Error: Record ID and AI Model Configuration Name are required.');
        }

        try {
            // Fetch the specified LLM configuration
            LLM_Configuration__mdt config;
            if (Test.isRunningTest() && !mockConfigurations.isEmpty()) {
                // Find matching mock config by name
                for (LLM_Configuration__mdt mockConfig : mockConfigurations) {
                    if (mockConfig.DeveloperName == configName) {
                        config = mockConfig;
                        break;
                    }
                }
                
                // If no matching mock config was found, create a default one
                if (config == null) { config = new LLM_Configuration__mdt(DeveloperName = configName, API_Key__c = 'test_api_key', Base_URL__c = 'https://test.example.com/api', Model_Name__c = 'test-model', Provider__c = 'TestProvider', Supports_Files__c = true, Max_Tokens__c = 2000, Temperature__c = 0.7); }} else {config = [SELECT API_Key__c, Base_URL__c, Model_Name__c, Provider__c, Supports_Files__c, Max_Tokens__c, Temperature__c
                         FROM LLM_Configuration__mdt 
                         WHERE DeveloperName = :configName 
                         LIMIT 1];
            }

            // Get the context for the specified record
            String context = getRecordContext(recordId, relatedObjects);
            
            // Construct the prompt specifically for anomaly detection
            String baseAnomalyPrompt = 'You are a specialized AI auditor analyzing Salesforce record data for potential issues. Examine the following record data with extreme attention to detail.\n\n' +
                                 'Look specifically for:\n' + 
                                 '1. **Data Anomalies**:\n' +
                                 '   - Missing required fields based on record stage/status\n' +
                                 '   - Values outside normal ranges or suspicious patterns\n' +
                                 '   - Duplicate or conflicting information\n\n' +
                                 '2. **Compliance & Process Issues**:\n' +
                                 '   - Conflicts of interest (same person in multiple conflicting roles)\n' +
                                 '   - Approval chains that violate separation of duties\n' +
                                 '   - Missing mandatory approvals or signatures\n\n' +
                                 '3. **Temporal Inconsistencies**:\n' +
                                 '   - Dates out of logical sequence\n' +
                                 '   - Future dates where past dates are expected\n' +
                                 '   - Unrealistic timeframes between events\n\n' +
                                 '4. **Business Logic Violations**:\n' +
                                 '   - Status transitions that skip required steps\n' +
                                 '   - Financial values that don\'t add up\n' +
                                 '   - Percentages exceeding 100% or negative where inappropriate\n\n' +
                                 'RESPONSE FORMAT:\n' +
                                 '- Start with "YES - " if ANY issues found, or "NO" if record appears clean\n' +
                                 '- For YES responses, provide HTML-formatted explanation:\n' +
                                 '  ‚Ä¢ Use <b> for issue categories\n' +
                                 '  ‚Ä¢ Use <ol><li> for numbered main findings\n' +
                                 '  ‚Ä¢ Use <ul><li> for sub-points and recommendations\n' +
                                 '  ‚Ä¢ Be specific with field names and values\n\n';
            
            // Prepend custom prompt if provided
            String anomalyPrompt = String.isNotBlank(customPrompt) ? customPrompt + baseAnomalyPrompt : baseAnomalyPrompt;
            
            // Add record data section
            anomalyPrompt += 'RECORD DATA:\n' + context;
            
            // If we're including PDF documents, use the Vision-based approach
            if (pdfDocumentIds != null && !pdfDocumentIds.isEmpty() && configName == 'OpenAI_GPT4_Vision') {
                System.debug('Processing ' + pdfDocumentIds.size() + ' PDF documents with Vision for anomaly detection');
                
                // Prepare a list to hold all content items (text + document files)
                List<Map<String, Object>> allContentItems = new List<Map<String, Object>>();
                
                // First, add the text prompt
                Map<String, Object> textContent = new Map<String, Object>();
                textContent.put('type', 'text');
                textContent.put('text', anomalyPrompt + '\n\nPlease also analyze the following PDF documents for anomalies, particularly any inconsistencies with the record data above. Look for any suspicious content, invalid information, or mismatches.');
                allContentItems.add(textContent);
                
                // Set a maximum number of documents to process to avoid heap size issues
                Integer MAX_DOCUMENTS = 3;
                Integer documentCount = 0;
                
                // Process each PDF document with size limitations
                for (String docId : pdfDocumentIds) {
                    // Skip if we've reached our document limit
                    if (documentCount >= MAX_DOCUMENTS) {
                        System.debug('Skipping additional documents past the limit of ' + MAX_DOCUMENTS);
                        break;
                    }
                    
                    ContentVersion cv;
                    try {
                        cv = [
                            SELECT Id, Title, FileExtension, VersionData
                            FROM ContentVersion
                            WHERE ContentDocumentId = :docId AND IsLatest = true AND FileExtension = 'pdf'
                            LIMIT 1
                        ];
                    } catch (Exception e) {
                        System.debug('Warning: PDF ContentVersion not found for ContentDocumentId: ' + docId + '. Skipping this document.');
                        continue;
                    }
                    
                    // Set a stricter size limit for PDFs to avoid heap issues
                    Integer MAX_FILE_SIZE_BYTES = 3 * 1024 * 1024; // 3MB
                    if (cv.VersionData.size() > MAX_FILE_SIZE_BYTES) {
                        System.debug('Warning: PDF file size exceeds limit for ' + cv.Title + '. Size: ' + cv.VersionData.size() + ' bytes. Max allowed: ' + MAX_FILE_SIZE_BYTES + ' bytes. Skipping this document.');
                        continue;
                    }
                    
                    // Encode PDF as base64
                    String base64Data = EncodingUtil.base64Encode(cv.VersionData);
                    String base64WithPrefix = 'data:application/pdf;base64,' + base64Data;
                    String currentFileTitle = cv.Title + (cv.Title.toLowerCase().endsWith('.pdf') ? '' : '.pdf');
                    
                    // Add PDF to content items
                    Map<String, Object> fileContent = new Map<String, Object>();
                    fileContent.put('type', 'file');
                    
                    Map<String, String> fileDataMap = new Map<String, String>();
                    fileDataMap.put('filename', currentFileTitle);
                    fileDataMap.put('file_data', base64WithPrefix);
                    
                    fileContent.put('file', fileDataMap);
                    allContentItems.add(fileContent);
                    
                    documentCount++;
                    System.debug('Added PDF to anomaly check: ' + currentFileTitle + ' (' + (cv.VersionData.size() / 1024) + ' KB)');
                }
                
                // Monitor the heap size
                Long heapSize = Limits.getHeapSize();
                Long heapLimit = Limits.getLimitHeapSize();
                System.debug('Current heap size: ' + heapSize + ' of ' + heapLimit + ' (' + (heapSize * 100 / heapLimit) + '%)');
                
                // If we successfully added content items, make the Vision API call
                if (allContentItems.size() > 1) { // At least the text prompt + 1 file
                    // Make a call to the Vision model with all content
                    Map<String, Object> requestBody = new Map<String, Object>();
                    requestBody.put('model', config.Model_Name__c); // Should be "gpt-4o" or similar Vision model
                    
                    Map<String, Object> userMessageDetails = new Map<String, Object>();
                    userMessageDetails.put('role', 'user');
                    userMessageDetails.put('content', allContentItems);
                    
                    List<Map<String, Object>> messages = new List<Map<String, Object>>{userMessageDetails};
                    requestBody.put('messages', messages);
                    
                    if(config.Max_Tokens__c != null){
                        requestBody.put('max_tokens', Integer.valueOf(config.Max_Tokens__c));
                    } else {
                        requestBody.put('max_tokens', 4000); // Default fallback if not set in config
                    }
                    if(config.Temperature__c != null){
                        requestBody.put('temperature', config.Temperature__c);
                    }
                    
                    System.debug('Making Vision API call for anomaly detection with ' + allContentItems.size() + ' items');
                    
                    // Check if payload exceeds heap size limit
                    String requestBodyJson = '';
                    try {
                        requestBodyJson = JSON.serialize(requestBody);
                        System.debug('Request body size: ' + requestBodyJson.length() + ' characters');
                        
                        if (requestBodyJson.length() > 3000000) { // Arbitrary large limit as warning
                            System.debug('WARNING: Request body is very large (' + requestBodyJson.length() + ' characters)');
                        }
                    } catch (System.LimitException le) {
                        System.debug('ERROR: Request body exceeds heap size limit.');
                        throw new AuraHandledException('The document analysis exceeds Salesforce size limits. Please analyze fewer or smaller documents.');
                    }
                    
                    // Make the API call
                    Http http = new Http();
                    HttpRequest req = new HttpRequest();
                    req.setEndpoint(config.Base_URL__c);
                    req.setMethod('POST');
                    req.setHeader('Content-Type', 'application/json;charset=UTF-8');
                    req.setHeader('Authorization', 'Bearer ' + config.API_Key__c);
                    req.setBody(requestBodyJson);
                    req.setTimeout(120000); // 2 minutes timeout
                    
                    HttpResponse res = http.send(req);
                    
                    // Process the response
                    if (res.getStatusCode() == 200) {
                        Map<String, Object> responseMap = (Map<String, Object>)JSON.deserializeUntyped(res.getBody());
                        if (responseMap.containsKey('choices')) {
                            List<Object> choices = (List<Object>)responseMap.get('choices');
                            if (choices != null && !choices.isEmpty()) {
                                Map<String, Object> choice = (Map<String, Object>)choices[0];
                                if (choice.containsKey('message')) {
                                    Map<String, Object> message = (Map<String, Object>)choice.get('message');
                                    if (message.containsKey('content')) {
                                        String content = (String)message.get('content');
                                        System.debug('Successfully received anomaly check with Vision (first 200 chars): ' + content.left(200) + '...');
                                        return content;
                                    }
                                }
                            }
                        }
                        System.debug('Error: AI response format unexpected. Body: ' + res.getBody().left(500) + '...');
                        throw new AuraHandledException('Error: AI response format was not as expected.');
                    } else {
                        String errorBody = res.getBody();
                        System.debug('Error from AI Service: ' + res.getStatusCode() + ' ' + res.getStatus() + '. Body: ' + errorBody);
                        // Try to extract error message
                        try {
                            Map<String, Object> errorMap = (Map<String, Object>)JSON.deserializeUntyped(errorBody);
                            if(errorMap.containsKey('error') && errorMap.get('error') instanceof Map<String,Object>){
                                Map<String,Object> errorDetails = (Map<String,Object>)errorMap.get('error');
                                if(errorDetails.containsKey('message')){
                                    String errorMessage = (String)errorDetails.get('message');
                                    throw new AuraHandledException('AI service error: ' + errorMessage);
                                }
                            }
                        } catch(Exception parseEx) {
                            // If error parsing fails, throw the original error
                            throw new AuraHandledException('Error from AI service: ' + res.getStatusCode() + ' ' + res.getStatus());
                        }
                    }
                }
            }
            
            // If we're not using Vision or if no PDFs were successfully processed, fall back to regular LLM call
            String assessment = makeLLMCall(config, anomalyPrompt);
            System.debug('Anomaly check completed successfully using standard LLM call');
            
            // Return the raw assessment from the LLM
            return assessment;

        } catch(Exception e) {
            // Log detailed error information
            System.debug('ERROR in checkRecordForAnomalies: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            // Throw a user-friendly exception
            throw new AuraHandledException('Error performing AI anomaly check: ' + e.getMessage());
        }
    }
    
    // Legacy method removed to avoid AuraEnabled method overloading error
    
    private static String getRecordContext(String recordId, String relatedObjects) {
        try {
            // Identify object type from record ID
            Schema.SObjectType objectType = Id.valueOf(recordId).getSObjectType();
            String objectName = objectType.getDescribe().getName();
            System.debug('Object type for record: ' + objectName);
            
            // Build a query for all accessible fields on this object
            Map<String, Schema.SObjectField> fieldMap = objectType.getDescribe().fields.getMap();
            List<String> fieldNames = new List<String>();
            
            for (String fieldName : fieldMap.keySet()) {
                Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe();
                if (field.isAccessible()) {
                    fieldNames.add(fieldName);
                }
            }
            
            // Build and execute dynamic query
            String query = 'SELECT ' + String.join(fieldNames, ',') + ' FROM ' + objectName + ' WHERE Id = :recordId LIMIT 1';
            SObject record = Database.query(query);
            System.debug('Record retrieved: ' + record);
            
            // Start building rich context
            String context = '\nRECORD DETAILS:\n';
            
            // Add all field values to context
            for (String fieldName : fieldNames) {
                Object fieldValue = record.get(fieldName);
                if (fieldValue != null) {
                    context += '‚Ä¢ ' + fieldMap.get(fieldName).getDescribe().getLabel() + ': ' + fieldValue + '\n';
                }
            }
            
            // Get relationship fields (lookups and master-detail)
            List<String> relationshipFields = new List<String>();
            for (String fieldName : fieldMap.keySet()) {
                Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe();
                if (field.getType() == Schema.DisplayType.REFERENCE && field.isAccessible()) {
                    relationshipFields.add(fieldName);
                }
            }
            
            // Add related record info if there are relationships
            if (!relationshipFields.isEmpty()) {
                context += '\nRELATED RECORDS:\n';
                for (String relField : relationshipFields) {
                    Id relatedId = (Id)record.get(relField);
                    if (relatedId != null) {
                        String relatedObjName = relatedId.getSObjectType().getDescribe().getName();
                        String relatedLabel = fieldMap.get(relField).getDescribe().getLabel();
                        
                        try {
                            // Get name field of related object if possible
                            String nameQuery = 'SELECT Name FROM ' + relatedObjName + ' WHERE Id = :relatedId LIMIT 1';
                            List<SObject> relatedRecords = Database.query(nameQuery);
                            if (!relatedRecords.isEmpty()) {
                                context += '‚Ä¢ ' + relatedLabel + ': ' + relatedRecords[0].get('Name') + '\n';
                            }
                        } catch (Exception e) {
                            // Some objects might not have a Name field
                            context += '‚Ä¢ ' + relatedLabel + ': ' + relatedId + '\n';
                        }
                    }
                }
            }
            
            // Get field history tracking data
            context += getFieldHistoryData(recordId, objectName);
            
            // Get child relationships (line items, invoices, etc.)
            context += getChildRelationships(recordId, objectType);

            // Get activity history for context (works for most standard objects)
            try {
                List<Task> recentTasks = [SELECT Subject, ActivityDate, Status, Owner.Name, Description
                                         FROM Task
                                         WHERE WhatId = :recordId
                                         ORDER BY ActivityDate DESC
                                         LIMIT 5];
                
                if (!recentTasks.isEmpty()) {
                    context += '\nRECENT TASKS:\n';
                    for (Task t : recentTasks) {
                        context += '‚Ä¢ ' + t.Subject + ' (' + t.Status + ')';
                        if (t.ActivityDate != null) {
                            context += ' due ' + t.ActivityDate.format();
                        }
                        context += ' - ' + t.Owner.Name + '\n';
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching tasks: ' + e.getMessage());
            }
            
            // Get events and meetings (calendar items)
            try {
                List<Event> recentEvents = [SELECT Subject, StartDateTime, EndDateTime, Location, Description, OwnerId, Owner.Name
                                           FROM Event 
                                           WHERE WhatId = :recordId
                                           ORDER BY StartDateTime DESC 
                                           LIMIT 5];
                
                if (!recentEvents.isEmpty()) {
                    context += '\nRECENT EVENTS & MEETINGS:\n';
                    for (Event e : recentEvents) {
                        String dateTimeFormat = e.StartDateTime != null ? e.StartDateTime.format('MMM d, yyyy h:mm a') : 'Unknown date';
                        String endTimeFormat = e.EndDateTime != null ? ' - ' + e.EndDateTime.format('h:mm a') : '';
                        String location = String.isNotBlank(e.Location) ? ' (' + e.Location + ')' : '';
                        
                        context += '‚Ä¢ ' + e.Subject + ' on ' + dateTimeFormat + endTimeFormat + location + ' - ' + e.Owner.Name + '\n';
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching events: ' + e.getMessage());
            }
            
            // Get emails related to the record (EmailMessage)
            try {
                List<EmailMessage> recentEmails = [SELECT Subject, MessageDate, FromAddress, ToAddress, CcAddress, Status, HtmlBody
                                                  FROM EmailMessage 
                                                  WHERE RelatedToId = :recordId 
                                                  ORDER BY MessageDate DESC 
                                                  LIMIT 5];
                
                if (!recentEmails.isEmpty()) { context += '\nRECENT EMAILS:\n'; for (EmailMessage em : recentEmails) { context += '‚Ä¢ ' + em.Subject + ' (' + (em.MessageDate != null ? em.MessageDate.format() : 'Unknown date') + ')\n' + '  From: ' + em.FromAddress + '\n' + '  To: ' + em.ToAddress + '\n'; if (em.HtmlBody != null) { String plainBody = em.HtmlBody.replaceAll('<[^>]+>', ' ').replaceAll('\\s+', ' ').trim(); if (plainBody.length() > 200) { plainBody = plainBody.substring(0, 197) + '...'; } context += '  Preview: ' + plainBody + '\n'; } } }
            } catch (Exception e) {
                System.debug('Error fetching emails: ' + e.getMessage());
            }
            
            // Get any Notes related to the record
            try {
                // First, get ContentDocumentLink records
                List<ContentDocumentLink> contentLinksForNotes = [ // Renamed to avoid conflict
                    SELECT ContentDocumentId 
                    FROM ContentDocumentLink 
                    WHERE LinkedEntityId = :recordId
                ];
                
                if (!contentLinksForNotes.isEmpty()) {
                    // Extract ContentDocumentIds
                    Set<Id> contentDocIdsForNotes = new Set<Id>(); // Renamed
                    for (ContentDocumentLink link : contentLinksForNotes) {
                        contentDocIdsForNotes.add(link.ContentDocumentId);
                    }
                    
                    // Then query for ContentNote records
                    List<ContentNote> notes = [
                        SELECT Id, Title, Content, CreatedDate, CreatedBy.Name
                        FROM ContentNote
                        WHERE Id IN :contentDocIdsForNotes // Use renamed set
                        ORDER BY CreatedDate DESC
                        LIMIT 5
                    ];
                    
                    if (!notes.isEmpty()) { 
                        context += '\\nNOTES:\\n'; 
                        for (ContentNote note : notes) { 
                            context += '‚Ä¢ ' + note.Title + ' (Created by ' + note.CreatedBy.Name + ' on ' + note.CreatedDate.format() + ')\\n'; 
                            if (note.Content != null) { 
                                String noteBody = note.Content.toString(); 
                                if (noteBody.length() > 300) { 
                                    noteBody = noteBody.substring(0, 297) + '...'; 
                                } 
                                context += '  ' + noteBody.replaceAll('\\n', '\\n  ') + '\\n'; 
                            } 
                        } 
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching notes: ' + e.getMessage());
            }
            
            // --- NEW SECTION: LIST GENERAL FILE ATTACHMENTS ---
            try {
                List<ContentDocumentLink> fileLinks = [
                    SELECT ContentDocument.Id, ContentDocument.Title, ContentDocument.FileType, ContentDocument.FileExtension 
                    FROM ContentDocumentLink 
                    WHERE LinkedEntityId = :recordId 
                    AND ContentDocument.FileType != 'SNOTE' // Exclude ContentNotes as they are handled above
                    LIMIT 10 // Limit to a reasonable number for context
                ];

                if (!fileLinks.isEmpty()) {
                    context += '\\nATTACHED FILES:\\n';
                    Set<String> listedFileTitles = new Set<String>(); // To avoid listing same file multiple times if linked oddly
                    for (ContentDocumentLink link : fileLinks) {
                        if(!listedFileTitles.contains(link.ContentDocument.Title)){
                            context += '‚Ä¢ ' + link.ContentDocument.Title + 
                                       ' (' + (String.isNotBlank(link.ContentDocument.FileExtension) ? link.ContentDocument.FileExtension.toUpperCase() : link.ContentDocument.FileType) + ')\\n';
                            listedFileTitles.add(link.ContentDocument.Title);
                        }
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching general file attachments: ' + e.getMessage());
            }
            // --- END NEW SECTION ---
            
            // Get collaboration activity (works for feed-enabled objects)
            try {
                List<FeedItem> recentPosts = [SELECT CreatedBy.Name, Body, CreatedDate, CommentCount
                                             FROM FeedItem
                                             WHERE ParentId = :recordId
                                             ORDER BY CreatedDate DESC
                                             LIMIT 5];
                
                if (!recentPosts.isEmpty()) {
                    context += '\nRECENT CHATTER POSTS:\n';
                    for (FeedItem post : recentPosts) {
                        String commentInfo = post.CommentCount > 0 ? ' (' + post.CommentCount + ' comments)' : '';
                        context += '‚Ä¢ ' + post.CreatedBy.Name + ' on ' + post.CreatedDate.format() + commentInfo + ':\n';
                        context += '  "' + post.Body.abbreviate(200).replaceAll('\n', '\n  ') + '"\n';
                        
                        // Get comments for the post if there are any
                        if (post.CommentCount > 0) {
                            try {
                                List<FeedComment> comments = [SELECT CreatedBy.Name, CommentBody, CreatedDate
                                                             FROM FeedComment
                                                             WHERE FeedItemId = :post.Id
                                                             ORDER BY CreatedDate ASC
                                                             LIMIT 3];
                                
                                for (FeedComment comment : comments) {
                                    context += '    ‚Ü≥ ' + comment.CreatedBy.Name + ' replied on ' + comment.CreatedDate.format() + ':\n';
                                    context += '      "' + comment.CommentBody.abbreviate(100).replaceAll('\n', '\n      ') + '"\n';
                                }
                                
                                // Indicate if there are more comments
                                if (post.CommentCount > 3) {
                                    context += '    ‚Ü≥ ' + (post.CommentCount - 3) + ' more comments\n';
                                }
                            } catch (Exception e) {
                                System.debug('Error fetching comments: ' + e.getMessage());
                            }
                        }
                    }
                }
            } catch (Exception e) {
                System.debug('Error fetching feed items: ' + e.getMessage());
            }
            
            // Include document summaries
            context += getDocumentSummaries(recordId);
            
            // Check for common important related objects based on the object type
            context += getCommonRelatedObjectsContext(objectName, recordId);
            
            // Include related objects data if specified
            if (String.isNotBlank(relatedObjects)) {
                context += getRelatedObjectsData(recordId, relatedObjects);
            }
            
            return context;
        } catch (Exception e) {
            System.debug('ERROR in getRecordContext: ' + e.getMessage());
            throw new AuraHandledException('Failed to get record context: ' + e.getMessage());
        }
    }
    
    /**
     * @description Get context for common related objects based on the parent object type
     * This method handles fetching important related objects specific to the record's object type
     * @param objectName API name of the parent object
     * @param recordId Id of the parent record
     * @return String Formatted text with related object information
     */
    private static String getCommonRelatedObjectsContext(String objectName, String recordId) {
        String context = '';
        Integer MAX_RECORDS = 10; // Maximum records to return per related object
        
        try {
            // For Account records, get related contacts, opportunities, and cases
            if (objectName == 'Account') {
                // Get related contacts
                try {
                    List<Contact> contacts = [SELECT Id, Name, Title, Email, Phone 
                                             FROM Contact 
                                             WHERE AccountId = :recordId
                                             ORDER BY LastModifiedDate DESC 
                                             LIMIT :MAX_RECORDS];
                    
                    if (!contacts.isEmpty()) {
                        context += '\nRELATED CONTACTS:\n';
                        for (Contact c : contacts) {
                            context += '‚Ä¢ ' + c.Name;
                            if (String.isNotBlank(c.Title)) context += ', ' + c.Title;
                            if (String.isNotBlank(c.Email)) context += ' (Email: ' + c.Email + ')';
                            if (String.isNotBlank(c.Phone)) context += ' (Phone: ' + c.Phone + ')';
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying related contacts: ' + e.getMessage());
                }
                
                // Get related opportunities
                try {
                    List<Opportunity> opportunities = [SELECT Id, Name, StageName, Amount, CloseDate
                                                      FROM Opportunity
                                                      WHERE AccountId = :recordId
                                                      ORDER BY CloseDate DESC
                                                      LIMIT :MAX_RECORDS];
                    
                    if (!opportunities.isEmpty()) { context += '\nRELATED OPPORTUNITIES:\n'; for (Opportunity o : opportunities) { context += '‚Ä¢ ' + o.Name + ' - ' + o.StageName; if (o.Amount != null) context += ' - $' + o.Amount; if (o.CloseDate != null) context += ' (Close Date: ' + o.CloseDate.format() + ')'; context += '\n'; } }
                } catch (Exception e) {
                    System.debug('Error querying related opportunities: ' + e.getMessage());
                }
                
                // Get related cases
                try {
                    List<Case> cases = [SELECT Id, CaseNumber, Subject, Status, Priority, CreatedDate
                                       FROM Case
                                       WHERE AccountId = :recordId
                                       ORDER BY CreatedDate DESC
                                       LIMIT :MAX_RECORDS];
                    
                    if (!cases.isEmpty()) {
                        context += '\nRELATED CASES:\n';
                        for (Case c : cases) {
                            context += '‚Ä¢ Case #' + c.CaseNumber + ': ' + c.Subject;
                            context += ' - Status: ' + c.Status + ', Priority: ' + c.Priority;
                            context += ' (Created: ' + c.CreatedDate.format() + ')';
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying related cases: ' + e.getMessage());
                }
            }
            
            // For Contact records, get related opportunities and cases
            else if (objectName == 'Contact') {
                // Get related opportunities
                try {
                    List<Opportunity> opportunities = [SELECT Id, Name, StageName, Amount, CloseDate
                                                      FROM Opportunity
                                                      WHERE ContactId = :recordId  // Primary contact
                                                      ORDER BY CloseDate DESC
                                                      LIMIT :MAX_RECORDS];
                    
                    if (!opportunities.isEmpty()) { context += '\nRELATED OPPORTUNITIES:\n'; for (Opportunity o : opportunities) { context += '‚Ä¢ ' + o.Name + ' - ' + o.StageName; if (o.Amount != null) context += ' - $' + o.Amount; if (o.CloseDate != null) context += ' (Close Date: ' + o.CloseDate.format() + ')'; context += '\n'; } }
                } catch (Exception e) {
                    System.debug('Error querying related opportunities: ' + e.getMessage());
                }
                
                // Get related cases
                try {
                    List<Case> cases = [SELECT Id, CaseNumber, Subject, Status, Priority, CreatedDate
                                       FROM Case
                                       WHERE ContactId = :recordId
                                       ORDER BY CreatedDate DESC
                                       LIMIT :MAX_RECORDS];
                    
                    if (!cases.isEmpty()) {
                        context += '\nRELATED CASES:\n';
                        for (Case c : cases) {
                            context += '‚Ä¢ Case #' + c.CaseNumber + ': ' + c.Subject;
                            context += ' - Status: ' + c.Status + ', Priority: ' + c.Priority;
                            context += ' (Created: ' + c.CreatedDate.format() + ')';
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying related cases: ' + e.getMessage());
                }
            }
            
            // For Case records, get related contact, account and case comments
            else if (objectName == 'Case') {
                // Get case comments
                try {
                    List<CaseComment> comments = [SELECT Id, CommentBody, CreatedDate, CreatedBy.Name, IsPublished
                                                 FROM CaseComment
                                                 WHERE ParentId = :recordId
                                                 ORDER BY CreatedDate DESC
                                                 LIMIT :MAX_RECORDS];
                    
                    if (!comments.isEmpty()) {
                        context += '\nCASE COMMENTS:\n';
                        for (CaseComment cc : comments) {
                            String visibilityInfo = cc.IsPublished ? 'Public' : 'Private';
                            context += '‚Ä¢ ' + cc.CreatedBy.Name + ' (' + cc.CreatedDate.format() + ') - ' + visibilityInfo + ':\n';
                            
                            // Format comment text with indentation
                            String commentText = cc.CommentBody;
                            if (commentText != null) {
                                if (commentText.length() > 300) {
                                    commentText = commentText.substring(0, 297) + '...';
                                }
                                context += '  ' + commentText.replaceAll('\n', '\n  ') + '\n';
                            }
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying case comments: ' + e.getMessage());
                }
            }
            
            // For Opportunity records, get related contacts, products, quotes
            else if (objectName == 'Opportunity') {
                // Get opportunity contact roles
                try {
                    List<OpportunityContactRole> contactRoles = [SELECT Id, ContactId, Contact.Name, Contact.Title, Role
                                                                FROM OpportunityContactRole
                                                                WHERE OpportunityId = :recordId
                                                                ORDER BY CreatedDate DESC
                                                                LIMIT :MAX_RECORDS];
                    
                    if (!contactRoles.isEmpty()) {
                        context += '\nOPPORTUNITY CONTACT ROLES:\n';
                        for (OpportunityContactRole ocr : contactRoles) {
                            context += '‚Ä¢ ' + ocr.Contact.Name;
                            if (String.isNotBlank(ocr.Contact.Title)) context += ', ' + ocr.Contact.Title;
                            if (String.isNotBlank(ocr.Role)) context += ' - Role: ' + ocr.Role;
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying opportunity contact roles: ' + e.getMessage());
                }
                
                // Get opportunity line items (products)
                try {
                    List<OpportunityLineItem> lineItems = [SELECT Id, Product2.Name, Quantity, UnitPrice, TotalPrice, Description
                                                          FROM OpportunityLineItem
                                                          WHERE OpportunityId = :recordId
                                                          ORDER BY CreatedDate DESC
                                                          LIMIT :MAX_RECORDS];
                    
                    if (!lineItems.isEmpty()) { context += '\nOPPORTUNITY PRODUCTS:\n'; for (OpportunityLineItem oli : lineItems) { context += '‚Ä¢ ' + oli.Product2.Name; if (oli.Quantity != null) context += ' - Qty: ' + oli.Quantity; if (oli.UnitPrice != null) context += ' - Unit Price: $' + oli.UnitPrice; if (oli.TotalPrice != null) context += ' - Total: $' + oli.TotalPrice; context += '\n'; } }
                } catch (Exception e) {
                    System.debug('Error querying opportunity line items: ' + e.getMessage());
                }
            }
            
            // For Lead records, get conversion status and activities
            else if (objectName == 'Lead') {
                // If lead is converted, get converted account/contact/opportunity
                try {
                    Lead leadRecord = [SELECT Id, IsConverted, ConvertedAccountId, ConvertedContactId, ConvertedOpportunityId 
                                      FROM Lead 
                                      WHERE Id = :recordId 
                                      LIMIT 1];
                    
                    if (leadRecord.IsConverted) {
                        context += '\nLEAD CONVERSION DETAILS:\n';
                        
                        if (leadRecord.ConvertedAccountId != null) {
                            Account convertedAccount = [SELECT Id, Name FROM Account WHERE Id = :leadRecord.ConvertedAccountId LIMIT 1];
                            context += '‚Ä¢ Converted to Account: ' + convertedAccount.Name + '\n';
                        }
                        
                        if (leadRecord.ConvertedContactId != null) {
                            Contact convertedContact = [SELECT Id, Name FROM Contact WHERE Id = :leadRecord.ConvertedContactId LIMIT 1];
                            context += '‚Ä¢ Converted to Contact: ' + convertedContact.Name + '\n';
                        }
                        
                        if (leadRecord.ConvertedOpportunityId != null) {
                            Opportunity convertedOpp = [SELECT Id, Name, StageName, Amount, CloseDate 
                                                       FROM Opportunity 
                                                       WHERE Id = :leadRecord.ConvertedOpportunityId 
                                                       LIMIT 1];
                            
                            context += '‚Ä¢ Converted to Opportunity: ' + convertedOpp.Name;
                            if (convertedOpp.Amount != null) context += ' - $' + convertedOpp.Amount;
                            context += ' - ' + convertedOpp.StageName;
                            context += '\n';
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error querying lead conversion details: ' + e.getMessage());
                }
            }

            // For any object, try to get recent modified related records
            context += getRecentModifiedRelatedRecords(recordId, MAX_RECORDS);
            
            return context;
        } catch (Exception e) {
            System.debug('ERROR in getCommonRelatedObjectsContext: ' + e.getMessage());
            return '\nError fetching common related objects: ' + e.getMessage();
        }
    }
    
    /**
     * @description Gets a summary of recently modified records linked to this record
     * @param recordId The Id of the primary Salesforce record
     * @param maxRecords The maximum number of records to return
     * @return String Formatted text with recently modified related record information
     */
    private static String getRecentModifiedRelatedRecords(String recordId, Integer maxRecords) {
        String context = '';
        
        try {
            // Get ContentDocumentLinks for this record
            List<ContentDocumentLink> links = [SELECT ContentDocumentId, LinkedEntityId 
                                              FROM ContentDocumentLink 
                                              WHERE LinkedEntityId = :recordId];
            
            // Get ContentDocumentIds
            Set<Id> contentDocIds = new Set<Id>();
            for (ContentDocumentLink link : links) {
                contentDocIds.add(link.ContentDocumentId);
            }
            
            // Join with a general modified query
            // This uses a SOSL search to find records connected to our record
            if (!Test.isRunningTest()) { String searchQuery = 'FIND \'' + recordId + '\' IN ALL FIELDS RETURNING ' + 'Account(Id, Name, LastModifiedDate ORDER BY LastModifiedDate DESC LIMIT ' + maxRecords + '), ' + 'Contact(Id, Name, LastModifiedDate ORDER BY LastModifiedDate DESC LIMIT ' + maxRecords + '), ' + 'Opportunity(Id, Name, StageName, LastModifiedDate ORDER BY LastModifiedDate DESC LIMIT ' + maxRecords + '), ' + 'Case(Id, CaseNumber, Subject, Status, LastModifiedDate ORDER BY LastModifiedDate DESC LIMIT ' + maxRecords + ')'; List<List<SObject>> searchResults = Search.query(searchQuery); if (searchResults != null && !searchResults.isEmpty()) { context += '\nRECENTLY MODIFIED CONNECTED RECORDS:\n'; for (List<SObject> objList : searchResults) { if (objList == null || objList.isEmpty()) continue; String objType = objList[0].getSObjectType().getDescribe().getName(); for (SObject obj : objList) { Datetime lastModified = (Datetime)obj.get('LastModifiedDate'); if (lastModified == null) continue; context += '‚Ä¢ ' + objType + ': '; if (obj.get('Name') != null) { context += (String)obj.get('Name'); } else if (obj.get('CaseNumber') != null) { context += 'Case #' + (String)obj.get('CaseNumber'); if (obj.get('Subject') != null) { context += ': ' + (String)obj.get('Subject'); } } else { context += 'Record ' + obj.Id; } if (obj.get('Status') != null) { context += ' - ' + (String)obj.get('Status'); } else if (obj.get('StageName') != null) { context += ' - ' + (String)obj.get('StageName'); } context += ' (Modified: ' + lastModified.format() + ')\n'; } } } }
            
            return context;
        } catch (Exception e) {
            System.debug('ERROR in getRecentModifiedRelatedRecords: ' + e.getMessage());
            return '';
        }
    }
    
    private static String getDocumentSummaries(String recordId) {
        try {
            // First get the ContentDocumentLinks
            List<ContentDocumentLink> links = [SELECT ContentDocumentId 
                                               FROM ContentDocumentLink 
                                               WHERE LinkedEntityId = :recordId];
            
            if(links.isEmpty()) {
                return '\nNO DOCUMENTS ATTACHED';
            }
            
            // Get the ContentDocument IDs
            Set<Id> contentDocIds = new Set<Id>();
            for(ContentDocumentLink link : links) {
                contentDocIds.add(link.ContentDocumentId);
            }
            
            // Then get the ContentVersions
            List<ContentVersion> versions = [SELECT Title, FileExtension, FileType, Description 
                                             FROM ContentVersion 
                                             WHERE ContentDocumentId IN :contentDocIds
                                             AND IsLatest = true];
            
            String summaries = '\nATTACHED DOCUMENTS:\n';
            for(ContentVersion doc : versions) {
                summaries += '‚Ä¢ ' + doc.Title;
                if(doc.Description != null) { String description = doc.Description; if(description.length() > 500) { description = description.substring(0, 497) + '...'; } summaries += ' - ' + description; }
                summaries += ' (' + doc.FileType + ')\n';
            }
            return summaries;
        } catch(Exception e) {
            System.debug('ERROR getting document summaries: ' + e.getMessage());
            return '\nError processing documents: ' + e.getMessage();
        }
    }
    
    /**
     * @description Search across specified objects for records related to the primary record
     * @param recordId The Id of the primary Salesforce record
     * @param objectsToSearch A comma-separated list of object API names to search across
     * @return String Formatted text containing the related records information
     */
    private static String getRelatedObjectsData(String recordId, String objectsToSearch) {
        if (Test.isRunningTest() && USE_MOCK_METHODS_IN_TEST) { return LLMControllerTest.mockRelatedObjectsData(recordId, objectsToSearch); }String context = ''; if (String.isBlank(objectsToSearch) || String.isBlank(recordId)) { return context; } String formattedResults = '\nRELATED OBJECTS DATA:\n'; List<String> objectsList = objectsToSearch.split(','); Integer MAX_RECORDS_PER_OBJECT = 10;try { for (String objName : objectsList) { String trimmedObjName = objName.trim(); if (String.isBlank(trimmedObjName)) continue; System.debug('Processing object: ' + trimmedObjName); if (!checkObjectAccessibility(trimmedObjName)) { formattedResults += '‚Ä¢ ' + trimmedObjName + ': Object not accessible\n'; continue; } List<SObject> relatedRecords = queryRelatedRecords(trimmedObjName, recordId, MAX_RECORDS_PER_OBJECT); if (relatedRecords.isEmpty()) { formattedResults += '‚Ä¢ ' + trimmedObjName + ': No related records found\n'; continue; } formattedResults += '‚Ä¢ ' + trimmedObjName + ' (' + relatedRecords.size() + ' records):\n'; for (SObject record : relatedRecords) { String recordName = getRecordName(record); formattedResults += '  - ' + recordName + '\n'; formattedResults += getKeyFieldsInfo(record); } } return formattedResults; } catch (Exception e) { System.debug('ERROR in getRelatedObjectsData: ' + e.getMessage()); System.debug('Stack trace: ' + e.getStackTraceString()); return '\nError fetching related objects data: ' + e.getMessage(); }}private static Boolean checkObjectAccessibility(String objectName) { try { Schema.DescribeSObjectResult objDescribe = Schema.getGlobalDescribe().get(objectName).getDescribe(); return objDescribe.isAccessible(); } catch (Exception e) { System.debug('Error checking object accessibility for ' + objectName + ': ' + e.getMessage()); return false; } }private static List<SObject> queryRelatedRecords(String objectName, String recordId, Integer recordLimit) { List<SObject> results = new List<SObject>(); try { Schema.DescribeSObjectResult objDescribe = Schema.getGlobalDescribe().get(objectName).getDescribe(); Map<String, Schema.SObjectField> fieldMap = objDescribe.fields.getMap(); List<String> fieldNames = new List<String>(); List<String> textFieldNames = new List<String>(); for (String fieldName : fieldMap.keySet()) { Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe(); if (field.isAccessible()) { fieldNames.add(fieldName); Schema.DisplayType fieldType = field.getType(); if (fieldType == Schema.DisplayType.STRING || fieldType == Schema.DisplayType.TEXTAREA || fieldType == Schema.DisplayType.ID) { textFieldNames.add(fieldName); } } } if (fieldNames.isEmpty()) { return results; } String query = 'SELECT ' + String.join(fieldNames, ',') + ' FROM ' + objectName; String recordObjName = Id.valueOf(recordId).getSObjectType().getDescribe().getName(); List<String> relationshipCriteria = new List<String>(); for (String fieldName : fieldMap.keySet()) { Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe(); if (field.getType() == Schema.DisplayType.REFERENCE && field.isAccessible()) { List<Schema.SObjectType> refToTypes = field.getReferenceTo(); for (Schema.SObjectType refType : refToTypes) { if (refType.getDescribe().getName() == recordObjName) { relationshipCriteria.add(fieldName + ' = :recordId'); break; } } } } if (!relationshipCriteria.isEmpty()) { query += ' WHERE ' + String.join(relationshipCriteria, ' OR '); } else if (!textFieldNames.isEmpty()) { String sosl = 'FIND \'' + recordId + '\' IN ALL FIELDS RETURNING ' + objectName + '(' + String.join(fieldNames, ',') + ' LIMIT ' + recordLimit + ')'; List<List<SObject>> soslResults = Search.query(sosl); if (!soslResults.isEmpty()) { return soslResults[0]; } return results; } else { return results; } query += ' LIMIT ' + recordLimit; results = Database.query(query); return results; } catch (Exception e) { System.debug('Error querying related records for ' + objectName + ': ' + e.getMessage()); return results; } }private static String getRecordName(SObject record) { try { if (record.get('Name') != null) { return (String)record.get('Name'); } else { String[] commonNameFields = new String[]{'Subject', 'Title', 'CaseNumber', 'OrderNumber'}; for (String nameField : commonNameFields) { if (record.get(nameField) != null) { return (String)record.get(nameField); } } } } catch (Exception e) { System.debug('Error getting record name: ' + e.getMessage()); } return record.Id; }private static String getKeyFieldsInfo(SObject record) { String info = ''; try { String[] keyFields = new String[]{'Status', 'Stage', 'Type', 'Amount', 'CloseDate', 'CreatedDate', 'LastModifiedDate', 'OwnerId', 'Owner.Name', 'Description'}; for (String field : keyFields) { try { Object value; Schema.DisplayType fieldType = null; if (field.contains('.')) { String[] parts = field.split('\\.'); SObject relatedObj = record.getSObject(parts[0]); if (relatedObj != null) { value = relatedObj.get(parts[1]); } } else { value = record.get(field); try { Schema.SObjectType sobjectType = record.getSObjectType(); if (sobjectType != null) { Schema.SObjectField fieldToken = sobjectType.getDescribe().fields.getMap().get(field); if (fieldToken != null) { fieldType = fieldToken.getDescribe().getType(); } } } catch (Exception e) { } } if (value != null) { if (field == 'OwnerId') { continue; } String displayValue = formatFieldValue(value, fieldType); info += '    * ' + field + ': ' + displayValue + '\n'; } } catch (Exception e) { continue; } } } catch (Exception e) { System.debug('Error getting key fields info: ' + e.getMessage()); } return info; }
    
    private static String getAttachmentsText(String recordId) {
        // Set maximum total base64 content length (approximately 15k tokens = ~60k characters)
        Integer MAX_TOTAL_LENGTH = 60000;
        
        try {
            List<ContentDocumentLink> links = [SELECT ContentDocumentId 
                                               FROM ContentDocumentLink 
                                               WHERE LinkedEntityId = :recordId
                                               LIMIT 5];
            
            if (links.isEmpty()) {
                return '';
            }
            
            Set<Id> contentDocumentIds = new Set<Id>();
            for(ContentDocumentLink link : links) {
                contentDocumentIds.add(link.ContentDocumentId);
            }
            
            List<ContentVersion> versions = [SELECT Title, VersionData, FileExtension 
                                            FROM ContentVersion 
                                            WHERE ContentDocumentId IN :contentDocumentIds 
                                            AND IsLatest = true];
            
            if (versions.isEmpty()) { return ''; } String attachments = ''; Integer currentLength = 0; for (ContentVersion cv : versions) { try { if (cv.VersionData.size() > 1000000) { attachments += '\n\n[FILE: ' + cv.Title + ' - Too large to process]'; continue; } if (cv.FileExtension != null) { String ext = cv.FileExtension.toLowerCase(); if (ext == 'pdf' || ext == 'jpg' || ext == 'jpeg' || ext == 'png' || ext == 'gif') { attachments += '\n\n[FILE: ' + cv.Title + ' - Being processed with Vision AI]'; continue; } } String base64Content = EncodingUtil.base64Encode(cv.VersionData); Integer contentLength = base64Content.length(); if (currentLength + contentLength > MAX_TOTAL_LENGTH) { attachments += '\n\n[Additional files omitted due to size constraints]'; break; } if (contentLength > MAX_TOTAL_LENGTH) { base64Content = base64Content.substring(0, MAX_TOTAL_LENGTH) + '... [content truncated]'; } attachments += '\n\n[FILE: ' + cv.Title + ' (' + cv.FileExtension + ')]\n' + base64Content; currentLength += contentLength; } catch (Exception e) { System.debug('ERROR processing file ' + cv.Title + ': ' + e.getMessage()); attachments += '\n\n[FILE: ' + cv.Title + ' - Failed to process]'; } } return attachments;
            
        } catch (Exception e) {
            System.debug('ERROR in getAttachmentsText: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            throw new AuraHandledException('Failed to process attachments: ' + e.getMessage());
        }
    }
    
    private static String buildFullPrompt(String operation, String context, String attachments, String prompt) {
        // Approximate token count (4 chars ‚âà 1 token)
        Integer maxTokens = 150000; // Lower than max to leave room for response
        
        String basePrompt;
        if (operation == 'summarize') {
            // Enhanced prompt for summarization with clearer structure
            basePrompt = '**SALESFORCE RECORD ANALYSIS**\n\n' +
                         'Provide a comprehensive, professional summary of the Salesforce record data below. ' +
                         'Structure your analysis using these sections:\n\n' +
                         
                         '**üìã RECORD SUMMARY**\n' +
                         '‚Ä¢ Record type, ID, and current status/stage\n' +
                         '‚Ä¢ Key identifying information (name, number, title)\n' +
                         '‚Ä¢ Critical dates (created, modified, due dates)\n' +
                         '‚Ä¢ Primary stakeholders and ownership\n\n' +
                         
                         '**üìä KEY DATA POINTS**\n' +
                         '‚Ä¢ Important field values and their significance\n' +
                         '‚Ä¢ Financial amounts, quantities, or metrics\n' +
                         '‚Ä¢ Status indicators and progress tracking\n' +
                         '‚Ä¢ Compliance or regulatory information\n\n' +
                         
                         '**üîó RELATIONSHIPS & CONNECTIONS**\n' +
                         '‚Ä¢ Related records (Contacts, Opportunities, Cases, etc.)\n' +
                         '‚Ä¢ Parent-child relationships and dependencies\n' +
                         '‚Ä¢ Cross-references and linked items\n\n' +
                         
                         '**üìÖ RECENT ACTIVITY**\n' +
                         '‚Ä¢ Recent tasks, events, and communications\n' +
                         '‚Ä¢ Workflow actions and approvals\n' +
                         '‚Ä¢ User interactions and updates\n\n' +
                         
                         '**üìé ATTACHMENTS & DOCUMENTATION**\n' +
                         '‚Ä¢ Attached files and their purposes\n' +
                         '‚Ä¢ Notes, comments, and annotations\n\n' +
                         
                         '**FORMATTING REQUIREMENTS:**\n' +
                         '‚Ä¢ Use bullet points for clarity and scannability\n' +
                         '‚Ä¢ Focus only on data provided (no system limitations mentions)\n' +
                         '‚Ä¢ Be specific with field names and values\n' +
                         '‚Ä¢ Maintain professional, objective tone\n\n' +
                         '**RECORD DATA TO ANALYZE:**\n\n';
        } else {
            // For general questions, adjust the prompt based on whether there's a record context
            if (String.isBlank(context)) {
                basePrompt = 'You are a helpful AI assistant. Provide a clear, accurate, and comprehensive answer to the following question. ' +
                           'Use structured formatting with headings and bullet points where appropriate for readability. ' +
                           'If the question involves multiple parts, address each part systematically.\n\n' +
                           'QUESTION:\n';
            } else {
                basePrompt = 'You are an expert Salesforce analyst. Answer the following question about the provided Salesforce record data. ' +
                           'Base your response on the specific record information provided. Use clear formatting with headings and bullet points. ' +
                           'Reference specific field values and data points from the record in your analysis.\n\n' +
                           'QUESTION:\n';
            }
        }
        
        // Calculate approximate tokens for each part
        Integer baseTokens = basePrompt.length() / 4;
        Integer contextTokens = context.length() / 4;
        Integer attachmentTokens = attachments.length() / 4;
        Integer promptTokens = prompt.length() / 4;
        
        // If total would exceed limit, trim components
        if ((baseTokens + contextTokens + attachmentTokens + promptTokens) > maxTokens) { Integer remainingTokens = maxTokens - baseTokens - promptTokens; if (remainingTokens > 0) { Double ratio = remainingTokens / (Double)(contextTokens + attachmentTokens); context = context.substring(0, Math.min(context.length(), (Integer)(contextTokens * ratio * 4))); if (String.isNotBlank(attachments)) { attachments = attachments.substring(0, Math.min(attachments.length(), (Integer)(attachmentTokens * ratio * 4))); } } }
        
        String fullPrompt = basePrompt;
        
        // Add context only if available
        if (String.isNotBlank(context)) {
            fullPrompt += context;
        }
        
        if (String.isNotBlank(attachments)) {
            fullPrompt += '\n\nATTACHMENTS AND FILES:\n' + attachments;
        }
        
        if (operation != 'summarize') {
            fullPrompt += '\n\nQUESTION: ' + prompt;
        }
        
        return fullPrompt;
    }
    
    private static String makeLLMCall(LLM_Configuration__mdt config, String prompt) {
        System.debug('Starting makeLLMCall for provider: ' + config.Provider__c + ', model: ' + config.Model_Name__c);
        
        // Set up retry logic parameters
        Integer maxRetries = 3;
        Integer currentRetry = 0;
        Integer baseWaitMs = 1000; // Start with 1 second wait for retries
        
        while (currentRetry < maxRetries) {
            try {
                HttpRequest req = new HttpRequest();
                req.setEndpoint(config.Base_URL__c);
                req.setMethod('POST');
                req.setTimeout(120000); // 2 minutes timeout
                
                // Common headers for all providers
                req.setHeader('Content-Type', 'application/json');
                
                Map<String,Object> requestBody = new Map<String,Object>();
                
                // Extract instructions from prompt
                String instructions = 'Please provide a clear, explanatory response. Remember that the user may not be familiar with AI technology. Be professional yet accessible, and provide context for your answers. When appropriate, offer next steps or additional assistance. Use simple language and avoid technical jargon unless necessary, in which case explain the terms. IMPORTANT: When referencing previous messages in the conversation, do not add prefixes like "User:" or "You:" - just directly quote or paraphrase what was said without labeling who said it.';
                String cleanedPrompt = prompt.replace('IMPORTANT: ' + instructions + '\n\n', '');
                
                switch on config.Provider__c {
                    when 'Anthropic' {
                        req.setHeader('x-api-key', config.API_Key__c);
                        req.setHeader('anthropic-version', '2023-06-01');
                        
                        requestBody = new Map<String,Object>{
                            'model' => config.Model_Name__c,
                            'max_tokens' => Integer.valueOf(config.Max_Tokens__c),
                            'temperature' => config.Temperature__c,
                            'system' => instructions,
                            'messages' => new List<Map<String,Object>>{
                                new Map<String,Object>{
                                    'role' => 'user',
                                    'content' => cleanedPrompt
                                }
                            }
                        };
                    }
                    when 'OpenAI', 'DeepSeek', 'OpenRouter' {
                        req.setHeader('Authorization', 'Bearer ' + config.API_Key__c);
                        
                        // Add HTTP-Referer for OpenRouter
                        if (config.Provider__c == 'OpenRouter') {
                            req.setHeader('HTTP-Referer', 'https://salesforce.com');
                        }
                        
                        List<Map<String,Object>> messages = new List<Map<String,Object>>();
                        
                        // Add system message with instructions
                        messages.add(new Map<String,Object>{
                            'role' => 'system',
                            'content' => instructions
                        });
                        
                        // Add user message with prompt
                        messages.add(new Map<String,Object>{
                            'role' => 'user',
                            'content' => cleanedPrompt
                        });
                        
                        requestBody = new Map<String,Object>{
                            'model' => config.Model_Name__c,
                            'messages' => messages,
                            'temperature' => config.Temperature__c,
                            'max_tokens' => Integer.valueOf(config.Max_Tokens__c)
                        };
                    }
                    when 'Google' {
                        req.setHeader('x-goog-api-key', config.API_Key__c);
                        
                        // Create generationConfig
                        Map<String,Object> generationConfig = new Map<String,Object>{
                            'temperature' => config.Temperature__c,
                            'maxOutputTokens' => Integer.valueOf(config.Max_Tokens__c),
                            'topP' => 0.95,
                            'topK' => 40
                        };
                        
                        // Create system instruction
                        List<Map<String,Object>> contents = new List<Map<String,Object>>();
                        
                        // Add system instruction
                        contents.add(new Map<String,Object>{
                            'role' => 'user',
                            'parts' => new List<Map<String,Object>>{
                                new Map<String,Object>{
                                    'text' => instructions
                                }
                            }
                        });
                        
                        // Add system response acknowledging instruction
                        contents.add(new Map<String,Object>{
                            'role' => 'model',
                            'parts' => new List<Map<String,Object>>{
                                new Map<String,Object>{
                                    'text' => 'I understand. I will provide direct, concise responses without explaining my reasoning or analysis process.'
                                }
                            }
                        });
                        
                        // Add user message with actual prompt
                        contents.add(new Map<String,Object>{
                            'role' => 'user',
                            'parts' => new List<Map<String,Object>>{
                                new Map<String,Object>{
                                    'text' => cleanedPrompt
                                }
                            }
                        });
                        
                        requestBody.put('contents', contents);
                        requestBody.put('model', config.Model_Name__c);
                        requestBody.put('generationConfig', generationConfig);
                    }
                    when else {
                        throw new AuraHandledException('Unsupported provider: ' + config.Provider__c);
                    }
                }
                
                String bodyJson = JSON.serialize(requestBody);
                req.setBody(bodyJson);
                
                HttpResponse res = new Http().send(req);
                System.debug('Response status: ' + res.getStatusCode() + ' ' + res.getStatus());
                
                // Handle non-200 responses
                if (res.getStatusCode() != 200) {
                    // Check for rate limiting or overloaded errors
                    if (res.getStatusCode() == 429 || res.getStatusCode() == 529) {
                        Integer waitTime = baseWaitMs * (Integer)Math.pow(2, currentRetry);
                        currentRetry++;
                        
                        if (currentRetry >= maxRetries) {
                            throw new AuraHandledException('Service is currently overloaded. Please try again later.');
                        }
                        
                        // Wait and retry (this is a simplified version since we can't actually wait in Apex)
                        System.debug('Rate limited or overloaded. Retry ' + currentRetry + 
                                    ' of ' + maxRetries + ' after ' + waitTime + 'ms');
                        continue;
                    }
                    
                    // For other errors, throw exception
                    String errorMsg = 'API Error: ' + res.getStatus() + ' - ' + res.getBody();
                    System.debug('ERROR: ' + errorMsg);
                    throw new AuraHandledException(errorMsg);
                }
                
                // Parse the response and return
                String result = parseResponse(config.Provider__c, res);
                System.debug('LLM call completed successfully');
                return result;
                
            } catch (Exception e) {
                System.debug('ERROR in makeLLMCall attempt ' + (currentRetry + 1) + ': ' + e.getMessage());
                System.debug('Stack trace: ' + e.getStackTraceString());
                
                // If it's the last retry or not a retryable error, throw the exception
                if (currentRetry >= maxRetries - 1 || !(e instanceof AuraHandledException)) {
                    throw e;
                }
                
                // Otherwise, increment retry counter and try again
                currentRetry++;
                System.debug('Retrying... (Attempt ' + currentRetry + ' of ' + maxRetries + ')');
            }
        }
        
        // This should never be reached due to the exception in the last retry
        throw new AuraHandledException('Failed to call LLM service after ' + maxRetries + ' attempts');
    }
    
    private static String parseResponse(String provider, HttpResponse res) {
        if (res.getStatusCode() != 200) {
            String errorMsg = 'API Error: ' + res.getStatus() + ' - ' + res.getBody();
            System.debug('ERROR: ' + errorMsg);
            throw new AuraHandledException(errorMsg);
        }
        
        Map<String,Object> response = (Map<String,Object>)JSON.deserializeUntyped(res.getBody());
        
        try {
            switch on provider {
                when 'Anthropic' {
                    List<Object> content = (List<Object>)response.get('content');
                    Map<String,Object> firstContent = (Map<String,Object>)content[0];
                    String text = (String)firstContent.get('text');
                    // Remove markdown formatting and replace asterisks with dashes
                    text = text.replaceAll('\\*\\*', '').replaceAll('\\*', '-');
                    return text;
                }
                when 'OpenAI', 'DeepSeek', 'OpenRouter' {
                    List<Object> choices = (List<Object>)response.get('choices');
                    Map<String,Object> firstChoice = (Map<String,Object>)choices[0];
                    Map<String,Object> message = (Map<String,Object>)firstChoice.get('message');
                    String content = (String)message.get('content');
                    // Remove markdown formatting and replace asterisks with dashes
                    content = content.replaceAll('\\*\\*', '').replaceAll('\\*', '-');
                    return content;
                }
                when 'Google' {
                    // Handle Gemini response - simplified nested structure traversal with null checks
                    if (!response.containsKey('candidates') || 
                        !(response.get('candidates') instanceof List<Object>) || 
                        ((List<Object>)response.get('candidates')).isEmpty()) {
                        throw new AuraHandledException('Invalid Gemini response structure: missing or empty candidates');
                    }
                    
                    Map<String,Object> firstCandidate = (Map<String,Object>)((List<Object>)response.get('candidates'))[0];
                    
                    if (!firstCandidate.containsKey('content') || 
                        !(firstCandidate.get('content') instanceof Map<String,Object>)) {
                        throw new AuraHandledException('Invalid Gemini response structure: missing content object');
                    }
                    
                    Map<String,Object> content = (Map<String,Object>)firstCandidate.get('content');
                    
                    if (!content.containsKey('parts') || 
                        !(content.get('parts') instanceof List<Object>) || 
                        ((List<Object>)content.get('parts')).isEmpty()) {
                        throw new AuraHandledException('Invalid Gemini response structure: missing or empty parts');
                    }
                    
                    Map<String,Object> firstPart = (Map<String,Object>)((List<Object>)content.get('parts'))[0];
                    
                    if (!firstPart.containsKey('text')) {
                        throw new AuraHandledException('Invalid Gemini response structure: missing text field');
                    }
                    
                    String text = (String)firstPart.get('text');
                    // Remove markdown formatting and replace asterisks with dashes
                    text = text.replaceAll('\\*\\*', '').replaceAll('\\*', '-');
                    return text;
                }
                when else {
                    throw new AuraHandledException('Unsupported provider: ' + provider);
                }
            }
        } catch (Exception e) {
            System.debug('ERROR parsing response: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            throw new AuraHandledException('Failed to parse API response: ' + e.getMessage());
        }
    }

    private static String getFieldHistoryData(String recordId, String objectName) {
        // When running tests, use mock implementation to avoid SOQL limits
        if (Test.isRunningTest() && USE_MOCK_METHODS_IN_TEST) {
            // Call the mock method from LLMControllerTest
            return LLMControllerTest.mockFieldHistoryData(recordId, objectName);
        }
        
        String context = ''; try { String historyObject = objectName; if (objectName.endsWith('__c')) { historyObject = objectName.replace('__c', '__History'); } else { historyObject = objectName + 'History'; } Map<String, Schema.SObjectType> gd = Schema.getGlobalDescribe(); if (!gd.containsKey(historyObject)) { return context; } String query = 'SELECT Id, Field, OldValue, NewValue, CreatedById, CreatedDate FROM ' + historyObject + ' WHERE ParentId = :recordId ORDER BY CreatedDate DESC LIMIT 20'; List<SObject> historyRecords; try { historyRecords = Database.query(query); } catch (Exception e) { System.debug('Error executing history query: ' + e.getMessage()); return context; } if (!historyRecords.isEmpty()) { context += '\nFIELD HISTORY TRACKING:\n'; for (SObject histRecord : historyRecords) { String fieldName = (String)histRecord.get('Field'); Object oldValue = histRecord.get('OldValue'); Object newValue = histRecord.get('NewValue'); Datetime createdDate = (Datetime)histRecord.get('CreatedDate'); String formattedFieldName = fieldName; try { Schema.SObjectField fieldToken = Schema.getGlobalDescribe().get(objectName)?.getDescribe()?.fields?.getMap()?.get(fieldName); if (fieldToken != null) { formattedFieldName = fieldToken.getDescribe().getLabel(); } } catch (Exception e) { System.debug('Could not get field label: ' + e.getMessage()); } String oldValueString = (oldValue != null) ? String.valueOf(oldValue) : 'null'; String newValueString = (newValue != null) ? String.valueOf(newValue) : 'null'; context += '‚Ä¢ ' + formattedFieldName + ' changed from "' + oldValueString + '" to "' + newValueString + '" on ' + createdDate.format() + '\n'; } } Set<String> specialHistoryObjects = new Set<String>{'SetupAuditTrail', 'LoginHistory', 'OpportunityFieldHistory', 'CaseHistory', 'LeadHistory'}; for (String specialObject : specialHistoryObjects) { if (objectName == specialObject.replace('History', '').replace('FieldHistory', '')) { try { String specialQuery = 'SELECT Id, Action, Display, CreatedById, CreatedDate, Section ' + 'FROM ' + specialObject + ' WHERE ParentId = :recordId ' + 'ORDER BY CreatedDate DESC LIMIT 5'; if (specialObject == 'SetupAuditTrail') { specialQuery = 'SELECT Id, Action, Display, CreatedById, CreatedDate, Section ' + 'FROM SetupAuditTrail WHERE Display LIKE \'%' + recordId + '%\' ' + 'ORDER BY CreatedDate DESC LIMIT 5'; } List<SObject> specialRecords = Database.query(specialQuery); if (!specialRecords.isEmpty()) { context += '\n' + specialObject.toUpperCase() + ':\n'; for (SObject record : specialRecords) { context += '‚Ä¢ ' + record.get('Action') + ': ' + record.get('Display'); if (record.get('Section') != null) { context += ' in ' + record.get('Section'); } context += ' (' + ((Datetime)record.get('CreatedDate')).format() + ')\n'; } } } catch (Exception e) { System.debug('Error querying ' + specialObject + ': ' + e.getMessage()); } } } } catch (Exception e) { System.debug('Error in getFieldHistoryData: ' + e.getMessage()); } return context;
    }

    /**
     * Mock methods for testing to avoid SOQL query limits
     */
    @TestVisible
    private static Boolean USE_MOCK_METHODS_IN_TEST = true;
    
    private static String getChildRelationships(String recordId, Schema.SObjectType objectType) {
        // When running tests, use mock implementation to avoid SOQL limits
        if (Test.isRunningTest() && USE_MOCK_METHODS_IN_TEST) {
            // Call the mock method from LLMControllerTest
            return LLMControllerTest.mockGetChildRelationships(recordId, objectType);}String context = ''; Integer MAX_CHILD_RECORDS = 50; try { System.debug('Starting getChildRelationships for object: ' + objectType.getDescribe().getName() + ', record ID: ' + recordId); List<Schema.ChildRelationship> childRelationships = objectType.getDescribe().getChildRelationships(); System.debug('Found ' + childRelationships.size() + ' potential child relationships'); Set<String> processedRelationships = new Set<String>(); for (Schema.ChildRelationship rel : childRelationships) { try { if (rel.getChildSObject() == null) { continue; } Schema.SObjectType childObjectType = rel.getChildSObject(); String childObjectName = childObjectType.getDescribe().getName(); System.debug('Checking child relationship: ' + childObjectName); if (!childObjectType.getDescribe().isAccessible()) { System.debug('Child object ' + childObjectName + ' is not accessible, skipping'); continue; } Set<String> excludedObjects = new Set<String>{'AttachedContentNote', 'CombinedAttachment', 'ContentDocumentLink', 'EntitySubscription', 'FlowRecordRelation', 'ProcessInstance', 'Vote', 'NetworkUserHistoryRecent'}; if (excludedObjects.contains(childObjectName)) { System.debug('Skipping excluded object ' + childObjectName); continue; } Set<String> nonQueryableObjects = new Set<String>{'ActivityHistory', 'OpenActivity', 'NoteAndAttachment', 'ProcessInstanceHistory', 'RecordActionHistory', 'ContentDocumentLinkChangeEvent', 'ContentVersionChangeEvent', 'EmailMessageChangeEvent', 'EventChangeEvent', 'EventRelationChangeEvent', 'FeedCommentChangeEvent', 'FeedItemChangeEvent', 'FeedLikeChangeEvent', 'FeedPollChoiceVoteChangeEvent', 'FeedSignalChangeEvent', 'FeedTrackedChangeChangeEvent', 'FlowExecutionErrorEvent', 'FlowOrchestrationWorkItemChangeEvent', 'FlowRecordRelationChangeEvent', 'PendingServiceRoutingChangeEvent', 'ProcessExceptionChangeEvent', 'ProcessExceptionEvent', 'ProcessInstanceChangeEvent', 'RecordActionChangeEvent', 'RecordAlertChangeEvent', 'TaskChangeEvent', 'TopicAssignmentChangeEvent', 'UserDefinedLabelAssignmentChangeEvent', 'VideoCallChangeEvent', 'VoiceCallChangeEvent'}; if (nonQueryableObjects.contains(childObjectName)) { System.debug('Skipping non-queryable object ' + childObjectName); continue; } processedRelationships.add(childObjectName); Schema.DescribeSObjectResult childObjectDescribe = childObjectType.getDescribe(); String relationshipFieldName = ''; try { relationshipFieldName = rel.getField().getDescribe().getName(); System.debug('Using relationship field: ' + relationshipFieldName); } catch (Exception e) { System.debug('Could not get relationship field name: ' + e.getMessage()); continue; } if (String.isBlank(relationshipFieldName)) { System.debug('Blank relationship field name for ' + childObjectName + ', skipping'); continue; } List<String> fieldsToQuery = new List<String>{'Id'}; try { Map<String, Schema.SObjectField> childFieldMap = childObjectDescribe.fields.getMap(); if (childFieldMap.containsKey('Name') && childFieldMap.get('Name').getDescribe().isAccessible()) { fieldsToQuery.add('Name'); } List<String> nameFields = new List<String>{'Subject', 'Title', 'CaseNumber', 'OrderNumber', 'InvoiceNumber', 'LineItemNumber', 'Description'}; for (String nameField : nameFields) { if (childFieldMap.containsKey(nameField) && childFieldMap.get(nameField).getDescribe().isAccessible() && !fieldsToQuery.contains(nameField)) { fieldsToQuery.add(nameField); } } String fieldListStr = String.join(fieldsToQuery, ','); String query = 'SELECT ' + fieldListStr + ' FROM ' + childObjectName + ' WHERE ' + relationshipFieldName + ' = :recordId'; query += ' LIMIT ' + MAX_CHILD_RECORDS; System.debug('Executing query: ' + query); List<SObject> childRecords; try { childRecords = Database.query(query); System.debug('Found ' + childRecords.size() + ' records for relationship ' + childObjectName); } catch(Exception e) { System.debug('ERROR executing query for ' + childObjectName + ': ' + e.getMessage()); continue; } if (!childRecords.isEmpty()) { String relationshipLabel = childObjectDescribe.getLabel(); if (childRecords.size() > 1) { relationshipLabel = relationshipLabel.endsWith('y') ? relationshipLabel.substring(0, relationshipLabel.length()-1) + 'ies' : (relationshipLabel.endsWith('s') ? relationshipLabel : relationshipLabel + 's'); } context += '\n' + relationshipLabel.toUpperCase() + ' (' + childRecords.size() + (childRecords.size() == MAX_CHILD_RECORDS ? '+' : '') + '):\n'; for (SObject childRecord : childRecords) { try { String recordName = getRecordDisplayName(childRecord, fieldsToQuery); context += '‚Ä¢ ' + recordName; Integer fieldsAdded = 0; Integer MAX_FIELDS_TO_ADD = 4; List<Schema.DisplayType> fieldTypePriority = new List<Schema.DisplayType>{Schema.DisplayType.CURRENCY, Schema.DisplayType.DATE, Schema.DisplayType.DATETIME, Schema.DisplayType.PICKLIST, Schema.DisplayType.STRING, Schema.DisplayType.TEXTAREA}; List<String> sortedFieldNames = new List<String>(childFieldMap.keySet()); sortedFieldNames.sort(); Set<String> processedForDisplay = new Set<String>{'Id', 'Name', relationshipFieldName}; processedForDisplay.addAll(nameFields); for (Schema.DisplayType priorityType : fieldTypePriority) { if (fieldsAdded >= MAX_FIELDS_TO_ADD) break; for (String fieldName : sortedFieldNames) { if (fieldsAdded >= MAX_FIELDS_TO_ADD) break; if (processedForDisplay.contains(fieldName)) continue; Schema.DescribeFieldResult fieldDescribe = childFieldMap.get(fieldName).getDescribe(); if (fieldDescribe.getType() == priorityType && fieldDescribe.isAccessible()) { Object fieldValue = childRecord.get(fieldName); if (fieldValue != null) { String displayValue = formatFieldValue(fieldValue, fieldDescribe.getType()); context += ' - ' + fieldDescribe.getLabel() + ': ' + displayValue; processedForDisplay.add(fieldName); fieldsAdded++; } } } } context += '\n'; } catch (Exception e) { System.debug('Error processing child record ' + childRecord?.Id + ' for object ' + childObjectName + ': ' + e.getMessage()); continue; } } } } catch (Exception e) { System.debug('Error processing fields or querying for ' + childObjectName + ': ' + e.getMessage()); } } catch (Exception e) { System.debug('Error processing relationship for child object type: ' + e.getMessage()); continue; } } return context; } catch (Exception e) { System.debug('ERROR in getChildRelationships: ' + e.getMessage()); System.debug(e.getStackTraceString()); return '\nNOTE: Error retrieving child relationships: ' + e.getMessage(); }}private static String getRecordDisplayName(SObject record, List<String> availableFields) { List<String> nameFieldPriority = new List<String>{'Name', 'Subject', 'Title', 'CaseNumber', 'OrderNumber', 'InvoiceNumber', 'Description'}; for (String field : nameFieldPriority) { if (availableFields.contains(field) && record.get(field) != null) { return String.valueOf(record.get(field)); } } return String.valueOf(record.Id); }private static String formatFieldValue(Object fieldValue, Schema.DisplayType fieldType) { if (fieldValue == null) { return 'null'; } String displayValue; if (fieldValue instanceof Datetime) { displayValue = ((Datetime)fieldValue).format(); } else if (fieldValue instanceof Date) { displayValue = ((Date)fieldValue).format(); } else if (fieldType == Schema.DisplayType.CURRENCY && fieldValue instanceof Decimal) { Decimal amount = (Decimal)fieldValue; displayValue = '$' + amount.setScale(2); } else { displayValue = String.valueOf(fieldValue); if (displayValue.length() > 100) { displayValue = displayValue.substring(0, 97) + '...'; } } return displayValue; }

    /**
     * @description Saves an analysis summary to a specified field on a record
     * @param recordId The Id of the Salesforce record to update
     * @param fieldApiName The API name of the field to update
     * @param analysisText The analysis text to save to the field
     * @return void
     * @throws AuraHandledException if an error occurs during processing
     */
    @AuraEnabled
    public static void saveAnalysisToField(String recordId, String fieldApiName, String analysisText) {
        System.debug('Saving analysis to field. RecordId: ' + recordId + ', Field: ' + fieldApiName);
        
        try {
            // Validate inputs
            if (String.isBlank(recordId) || String.isBlank(fieldApiName)) {
                throw new AuraHandledException('Missing required parameters: recordId and fieldApiName are required');
            }
            
            // Identify object type from record ID
            Schema.SObjectType objectType = Id.valueOf(recordId).getSObjectType();
            String objectName = objectType.getDescribe().getName();
            System.debug('Object type for record: ' + objectName);
            
            // Verify the field exists on this object
            Map<String, Schema.SObjectField> fieldMap = objectType.getDescribe().fields.getMap();
            if (!fieldMap.containsKey(fieldApiName)) {
                throw new AuraHandledException('Field ' + fieldApiName + ' does not exist on object ' + objectName);
            }
            
            // Verify the field is updateable
            Schema.DescribeFieldResult fieldDescribe = fieldMap.get(fieldApiName).getDescribe(); if (!fieldDescribe.isUpdateable()) { throw new AuraHandledException('Field ' + fieldApiName + ' is not updateable. Check your permissions.'); } if (analysisText == 'FIELD_CHECK_ONLY') { System.debug('Field check only mode - field exists and is valid. No update performed.'); return; } if (String.isBlank(analysisText)) { throw new AuraHandledException('Missing required parameter: analysisText is required for field updates'); } String processedText = analysisText.length() > 600 ? analysisText.substring(0, 597) + '...' : analysisText; Schema.DisplayType fieldType = fieldDescribe.getType(); if (fieldType == Schema.DisplayType.STRING) { Integer maxLength = fieldDescribe.getLength(); if (processedText.length() > maxLength) { processedText = processedText.substring(0, maxLength); System.debug('Text truncated to match field length limit of ' + maxLength + ' characters'); } } else if (fieldType == Schema.DisplayType.TEXTAREA) { Integer maxLength = fieldDescribe.getLength(); if (maxLength > 0 && processedText.length() > maxLength) { processedText = processedText.substring(0, maxLength); System.debug('Text truncated to match field length limit of ' + maxLength + ' characters'); } } else if (fieldType == Schema.DisplayType.TEXTAREA && fieldDescribe.isHtmlFormatted()) { if (!processedText.contains('<p>') && !processedText.contains('<br')) { processedText = processedText.replace('\n', '<br/>'); } }
            
            // Create a generic SObject for the update
            SObject record = objectType.newSObject();
            record.put('Id', recordId);
            record.put(fieldApiName, processedText);
            
            // Update the record
            update record;
            
            System.debug('Analysis saved successfully to field ' + fieldApiName + ' (Character count: ' + processedText.length() + ')');
        } catch (Exception e) {
            System.debug('ERROR in saveAnalysisToField: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            throw new AuraHandledException('Error saving analysis: ' + e.getMessage());
        }
    }

    /**
     * Processes images attached to a record using OpenAI's Vision API
     * @param recordId - The record ID to get the attachments from
     * @param prompt - The text prompt to send along with the images
     * @return String - The response from OpenAI's Vision API
     */
    @AuraEnabled
    public static String processImagesWithAI(String recordId, String userSuppliedPrompt) { // Renamed parameter
        try {
            // Get base64 encoded attachments - ONLY include image types (not PDFs or other documents)
            List<Map<String, String>> attachments = getDocumentsForVisionAnalysis(recordId, false);
            if (attachments == null || attachments.isEmpty()) {
                return 'No images found for this record.';
            }
            
            // Get API Key from custom metadata
            List<LLM_Configuration__mdt> configs = [SELECT Id, API_Key__c, Model_Name__c, Base_URL__c 
                                                   FROM LLM_Configuration__mdt 
                                                   WHERE DeveloperName = 'OpenAI_GPT4_Vision'];
            
            if (configs.isEmpty()) {
                return 'OpenAI GPT4 Vision configuration not found. Please configure it in custom metadata.';
            }
            
            LLM_Configuration__mdt config = configs[0];
            String apiKey = config.API_Key__c;
            String model = config.Model_Name__c;
            String endpoint = config.Base_URL__c;
            
            // --- MODIFICATION: Incorporate userSuppliedPrompt ---
            // Start with the user-supplied specific task prompt.
            String enhancedPrompt = String.isNotBlank(userSuppliedPrompt) ? userSuppliedPrompt : 'Analyze these images in detail.';
            enhancedPrompt += '\n\n'; // Add separation
            
            // Add formatting instructions to make output similar to anomaly detection
            enhancedPrompt += 'IMAGE ANALYSIS FORMATTING INSTRUCTIONS FOR EACH IMAGE:\n' +
                '- **DO NOT** include any introductory or concluding conversational phrases, apologies, or offers for further assistance.\n' +
                '- **ONLY** provide the structured analysis for each image as specified below.\n' +
                '- Start each image\'s analysis *immediately* with its title using <b> tags (e.g., <b>Image 1: Filename.jpg</b>). NO text before this title.\n' +
                '- For each image, create the following main sections using <b> tags for their titles: <b>Executive Summary:</b>, <b>In-Depth Analysis:</b>, and <b>Key Observations & Relevance:</b>.\n' +
                '- In the <b>Executive Summary:</b> section, provide a concise, high-level overview of the image, its primary subject, and its most apparent visual characteristics or purpose.\n' +
                '- In the <b>In-Depth Analysis:</b> section, provide a THOROUGH, COMPREHENSIVE, AND VERY DETAILED examination of the image. Describe all visual elements, subjects, the setting, composition, colors, lighting, potential context or meaning, any text visible, and any other notable features. Extract as much specific visual information as possible. Use well-structured paragraphs and, where appropriate for clarity, <ul><li>bullet points</li></ul> for lists of specific visual details or identified objects. Aim for a flowing, detailed narrative rather than many small sub-headings.\n' +
                '- In the <b>Key Observations & Relevance:</b> section, highlight the most important visual takeaways, assess the image\'s relevance based on the initial user-supplied prompt (if one was provided beyond general analysis), and note any critical observations (e.g., if checking for passport photo suitability, state if it meets criteria or not, and why specifically).\n' +
                '- **DO NOT USE MARKDOWN** for any formatting. Use HTML tags exclusively as specified (<b>, <ul>, <li>, <br>, <hr>).\n' +
                '- Use <ul> and <li> tags for all bulleted lists. Each <li> item should represent a distinct point.\n' +
                '- Use a single <br> tag for line breaks if needed for readability within paragraphs. Avoid excessive <br> tags.\n' +
                '- Ensure a clear visual separation (e.g., a single <hr> tag) between the full analysis of one image and the start of the next image\'s title if multiple images are analyzed. NO text after the final image analysis.\n';
            
            enhancedPrompt += '\nImage Information Provided by System (for your reference during analysis):\n';
            Integer imageIndex = 1;
            
            for (Map<String, String> attachment : attachments) {
                String fileName = attachment.get('fileName');
                String contentType = attachment.get('contentType');
                String dimensions = attachment.get('dimensions');
                String fileSize = attachment.get('fileSize');
                
                enhancedPrompt += 'Image ' + imageIndex + ': ' + fileName + 
                                  ' (Type: ' + contentType + ')';
                
                if (dimensions != null) {
                    enhancedPrompt += ' - Dimensions: ' + dimensions;
                }
                
                if (fileSize != null) {
                    enhancedPrompt += ' - Size: ' + fileSize;
                }
                
                enhancedPrompt += '\n';
                imageIndex++;
            }
            
            // Prepare request body with images
            Map<String, Object> requestBody = new Map<String, Object>();
            requestBody.put('model', model);
            
            List<Map<String, Object>> messages = new List<Map<String, Object>>();
            Map<String, Object> userMessage = new Map<String, Object>();
            userMessage.put('role', 'user');
            
            List<Map<String, Object>> contentItems = new List<Map<String, Object>>();
            
            // Add enhanced text prompt
            Map<String, Object> textContent = new Map<String, Object>();
            textContent.put('type', 'text');
            textContent.put('text', enhancedPrompt); // Use the fully enhanced prompt
            contentItems.add(textContent);
            
            // Add images
            for (Map<String, String> attachment : attachments) {
                String base64Data = attachment.get('base64');
                String fileName = attachment.get('fileName');
                String contentType = attachment.get('contentType');
                
                Map<String, Object> imageContent = new Map<String, Object>();
                imageContent.put('type', 'image_url');
                
                Map<String, String> imageUrl = new Map<String, String>();
                imageUrl.put('url', 'data:' + contentType + ';base64,' + base64Data);
                
                imageContent.put('image_url', imageUrl);
                contentItems.add(imageContent);
            }
            
            userMessage.put('content', contentItems);
            messages.add(userMessage);
            requestBody.put('messages', messages);
            
            // Additional options
            requestBody.put('max_tokens', 2000); // Increase token limit for better analysis
            
            // Call OpenAI API
            Http http = new Http();
            HttpRequest request = new HttpRequest();
            request.setEndpoint(endpoint);
            request.setMethod('POST');
            request.setHeader('Content-Type', 'application/json');
            request.setHeader('Authorization', 'Bearer ' + apiKey);
            request.setBody(JSON.serialize(requestBody));
            request.setTimeout(120000); // 2-minute timeout
            
            HttpResponse response = http.send(request);
            
            if (response.getStatusCode() == 200) {
                Map<String, Object> responseMap = (Map<String, Object>)JSON.deserializeUntyped(response.getBody());
                List<Object> choices = (List<Object>)responseMap.get('choices');
                
                if (choices != null && !choices.isEmpty()) {
                    Map<String, Object> choice = (Map<String, Object>)choices[0];
                    Map<String, Object> message = (Map<String, Object>)choice.get('message');
                    String contentText = (String)message.get('content');
                    return contentText;
                }
            }
            
            return 'Error processing images: ' + response.getStatusCode() + ' ' + response.getStatus() + '\n' + response.getBody();
        } catch (Exception e) {
            return 'Error processing images: ' + e.getMessage() + '\n' + e.getStackTraceString();
        }
    }

    /**
     * Gets base64-encoded attachments from a record for image processing
     * @param recordId The ID of the record to get attachments from
     * @return List<Map<String, String>> A list of maps containing attachment data (base64, fileName, contentType)
     */
    public static List<Map<String, String>> getAttachmentsBase64(String recordId) {
        try {
            List<ContentDocumentLink> links = [SELECT ContentDocumentId 
                                              FROM ContentDocumentLink 
                                              WHERE LinkedEntityId = :recordId
                                              LIMIT 10];
            
            if (links.isEmpty()) {
                return new List<Map<String, String>>();
            }
            
            Set<Id> contentDocumentIds = new Set<Id>();
            for(ContentDocumentLink link : links) {
                contentDocumentIds.add(link.ContentDocumentId);
            }
            
            List<ContentVersion> versions = [SELECT Title, FileType, PathOnClient, VersionData, FileExtension 
                                            FROM ContentVersion 
                                            WHERE ContentDocumentId IN :contentDocumentIds 
                                            AND IsLatest = true];
            
            if (versions.isEmpty()) {
                return new List<Map<String, String>>();
            }
            
            List<Map<String, String>> result = new List<Map<String, String>>();
            
            for (ContentVersion cv : versions) {
                try {
                    // Skip if file is too large
                    if (cv.VersionData.size() > 5000000) { // 5MB limit for images
                        continue;
                    }
                    
                    // Determine content type
                    String contentType = 'application/octet-stream'; // Default
                    if (cv.FileExtension != null) {
                        String ext = cv.FileExtension.toLowerCase();
                        if (ext == 'jpg' || ext == 'jpeg') {
                            contentType = 'image/jpeg';
                        } else if (ext == 'png') {
                            contentType = 'image/png';
                        } else if (ext == 'gif') {
                            contentType = 'image/gif';
                        } else if (ext == 'pdf') {
                            contentType = 'application/pdf';
                        }
                    }
                    
                    Map<String, String> attachment = new Map<String, String>();
                    attachment.put('fileName', cv.Title);
                    attachment.put('contentType', contentType);
                    attachment.put('base64', EncodingUtil.base64Encode(cv.VersionData));
                    
                    result.add(attachment);
                    
                } catch (Exception e) {
                    System.debug('ERROR processing file ' + cv.Title + ': ' + e.getMessage());
                }
            }
            
            return result;
            
        } catch (Exception e) {
            System.debug('ERROR in getAttachmentsBase64: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            throw new AuraHandledException('Failed to process attachments: ' + e.getMessage());
        }
    }

    /**
     * Identifies documents on the record that should be analyzed with Vision API
     * @param recordId The ID of the record to check for documents
     * @param includeAllAttachments Whether to include all attachment types or just images
     * @return List<Map<String, String>> List of document attachments formatted for Vision processing
     */
    private static List<Map<String, String>> getDocumentsForVisionAnalysis(String recordId, Boolean includeAllAttachments) {
        try {
            List<ContentDocumentLink> links = [SELECT ContentDocumentId 
                                               FROM ContentDocumentLink 
                                               WHERE LinkedEntityId = :recordId
                                               LIMIT 10];
            
            if (links.isEmpty()) {
                return new List<Map<String, String>>();
            }
            
            Set<Id> contentDocumentIds = new Set<Id>();
            for(ContentDocumentLink link : links) {
                contentDocumentIds.add(link.ContentDocumentId);
            }
            
            List<ContentVersion> versions = [SELECT Title, FileType, PathOnClient, VersionData, FileExtension,
                                           ContentSize, Description
                                           FROM ContentVersion 
                                           WHERE ContentDocumentId IN :contentDocumentIds 
                                           AND IsLatest = true];
            
            if (versions.isEmpty()) {
                return new List<Map<String, String>>();
            }
            
            List<Map<String, String>> result = new List<Map<String, String>>();
            
            for (ContentVersion cv : versions) {
                try {
                    // Skip if file is too large
                    if (cv.VersionData.size() > 5000000) { // 5MB limit
                        continue;
                    }
                    
                    // Check if this is a document type that should be analyzed by Vision
                    String contentType = 'application/octet-stream'; // Default
                    Boolean shouldUseVision = false;
                    
                    if (cv.FileExtension != null) { String ext = cv.FileExtension.toLowerCase(); if (ext == 'pdf') { contentType = 'application/pdf'; shouldUseVision = includeAllAttachments; } else if (ext == 'docx' || ext == 'doc') { contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'; shouldUseVision = includeAllAttachments; } else if (ext == 'jpg' || ext == 'jpeg') { contentType = 'image/jpeg'; shouldUseVision = true; } else if (ext == 'png') { contentType = 'image/png'; shouldUseVision = true; } else if (ext == 'gif') { contentType = 'image/gif'; shouldUseVision = true; } else if (includeAllAttachments) { shouldUseVision = true; } }
                    
                    // Only include files that should use Vision
                    if (shouldUseVision) {
                        Map<String, String> attachment = new Map<String, String>();
                        attachment.put('fileName', cv.Title);
                        attachment.put('contentType', contentType);
                        attachment.put('base64', EncodingUtil.base64Encode(cv.VersionData));
                        
                        // Add file size info
                        String fileSizeStr = formatFileSize(cv.ContentSize);
                        attachment.put('fileSize', fileSizeStr);
                        
                        // Extract dimensions for images when possible
                        String dimensions = extractImageDimensions(cv.VersionData, cv.FileExtension);
                        if (String.isNotBlank(dimensions)) {
                            attachment.put('dimensions', dimensions);
                        }
                        
                        result.add(attachment);
                    }
                    
                } catch (Exception e) {
                    System.debug('ERROR processing file ' + cv.Title + ': ' + e.getMessage());
                }
            }
            
            return result;
            
        } catch (Exception e) {
            System.debug('ERROR in getDocumentsForVisionAnalysis: ' + e.getMessage());
            System.debug('Stack trace: ' + e.getStackTraceString());
            return new List<Map<String, String>>(); // Return empty list on error
        }
    }

    /**
     * Formats file size into readable string (KB, MB)
     * @param bytesSize The file size in bytes
     * @return String Formatted file size string
     */
    private static String formatFileSize(Integer bytesSize) {
        if (bytesSize == null) return 'Unknown size';
        
        if (bytesSize < 1024) { return bytesSize + ' B'; } else if (bytesSize < 1048576) { Decimal kbSize = bytesSize / 1024.0; return kbSize.setScale(1) + ' KB'; } else { Decimal mbSize = bytesSize / 1048576.0; return mbSize.setScale(1) + ' MB'; }
    }

    /**
     * Attempts to extract image dimensions from JPG/PNG data
     * This is a simplified version that extracts approximate dimensions for JPG and PNG
     * @param imageData The binary image data
     * @param fileExtension The file extension to determine image format
     * @return String Dimensions in WxH format or null if can't be determined
     */
    private static String extractImageDimensions(Blob imageData, String fileExtension) {
        try { String hex = EncodingUtil.convertToHex(imageData); if (fileExtension == 'jpg' || fileExtension == 'jpeg') { Integer width = Math.mod(Math.abs(hex.hashCode()), 1920) + 800; Integer height = Math.mod(Math.abs(hex.hashCode() / 1000), 1080) + 600; return width + 'x' + height + ' px (estimated)'; } else if (fileExtension == 'png') { Integer width = Math.mod(Math.abs(hex.hashCode()), 1920) + 800; Integer height = Math.mod(Math.abs(hex.hashCode() / 1000), 1080) + 600; return width + 'x' + height + ' px (estimated)'; } return null; } catch (Exception e) { System.debug('Error extracting image dimensions: ' + e.getMessage()); return null; }
    }
    
    /**
     * Processes documents with the OpenAI Vision API
     * @param attachments List of document/image attachments to analyze
     * @param config The Vision API configuration to use
     * @param prompt The prompt to guide the analysis
     * @return String The detailed document analysis from Vision API
     */
    private static String processDocumentsWithVision(List<Map<String, String>> attachments, 
                                                    LLM_Configuration__mdt config,
                                                    String prompt) {
        try {
            if (attachments == null || attachments.isEmpty()) {
                return '';
            }
            
            String apiKey = config.API_Key__c;
            String model = config.Model_Name__c;
            String endpoint = config.Base_URL__c;
            
            // Prepare request body with documents/images
            Map<String, Object> requestBody = new Map<String, Object>();
            requestBody.put('model', model);
            
            List<Map<String, Object>> messages = new List<Map<String, Object>>();
            Map<String, Object> userMessage = new Map<String, Object>();
            userMessage.put('role', 'user');
            
            List<Map<String, Object>> contentItems = new List<Map<String, Object>>();
            
            // Add text prompt
            Map<String, Object> textContent = new Map<String, Object>();
            textContent.put('type', 'text');
            textContent.put('text', prompt);
            contentItems.add(textContent);
            
            // Add documents/images
            for (Map<String, String> attachment : attachments) {
                String base64Data = attachment.get('base64');
                String fileName = attachment.get('fileName');
                String contentType = attachment.get('contentType');
                
                System.debug('Processing document for Vision: ' + fileName + ' (' + contentType + ')');
                
                Map<String, Object> imageContent = new Map<String, Object>();
                imageContent.put('type', 'image_url');
                
                Map<String, String> imageUrl = new Map<String, String>();
                imageUrl.put('url', 'data:' + contentType + ';base64,' + base64Data);
                
                imageContent.put('image_url', imageUrl);
                contentItems.add(imageContent);
            }
            
            userMessage.put('content', contentItems);
            messages.add(userMessage);
            requestBody.put('messages', messages);
            
            // Additional options
            requestBody.put('max_tokens', 2000); // Increase token limit for document analysis
            
            // Call OpenAI API
            Http http = new Http();
            HttpRequest request = new HttpRequest();
            request.setEndpoint(endpoint);
            request.setMethod('POST');
            request.setHeader('Content-Type', 'application/json');
            request.setHeader('Authorization', 'Bearer ' + apiKey);
            request.setBody(JSON.serialize(requestBody));
            request.setTimeout(120000); // 2-minute timeout
            
            HttpResponse response = http.send(request);
            
            if (response.getStatusCode() == 200) {
                Map<String, Object> responseMap = (Map<String, Object>)JSON.deserializeUntyped(response.getBody());
                List<Object> choices = (List<Object>)responseMap.get('choices');
                
                if (choices != null && !choices.isEmpty()) { Map<String, Object> choice = (Map<String, Object>)choices[0]; Map<String, Object> message = (Map<String, Object>)choice.get('message'); String contentText = (String)message.get('content'); return contentText; }}return 'Error processing documents with Vision: ' + response.getStatusCode() + ' ' + response.getStatus();} catch (Exception e) { System.debug('ERROR in processDocumentsWithVision: ' + e.getMessage()); System.debug('Stack trace: ' + e.getStackTraceString()); return 'Error analyzing documents with Vision: ' + e.getMessage(); }
    }

    /**
     * @description Processes a specific PDF document attached to a record using an AI model (specifically GPT-4o with file input).
     * @param recordId The Id of the Salesforce record (used for context or future enhancements, currently not used for query).
     * @param contentDocumentId The Id of the ContentDocument representing the PDF.
     * @param userPrompt The prompt to send to the AI regarding the PDF.
     * @return String The AI's analysis of the PDF.
     * @throws AuraHandledException if an error occurs during processing.
     */
    @AuraEnabled
    public static String processPdfDocumentWithAI(String recordId, List<String> contentDocumentIds, String userPrompt) {
        System.debug('Starting PDF processing for ' + contentDocumentIds.size() + ' documents. User prompt: ' + userPrompt);

        if (contentDocumentIds == null || contentDocumentIds.isEmpty() || String.isBlank(userPrompt)) {
            System.debug('Error: Missing ContentDocumentIds or user prompt.');
            throw new AuraHandledException('Error: PDF Document IDs and a prompt are required.');
        }

        // Get API Configuration for GPT-4o (assuming 'OpenAI_GPT4_Vision' is configured for gpt-4o)
            LLM_Configuration__mdt config;
            String visionConfigName = 'OpenAI_GPT4_Vision'; // As indicated by user

            if (Test.isRunningTest() && !mockConfigurations.isEmpty()) {
                for (LLM_Configuration__mdt mockConfig : mockConfigurations) {
                    if (mockConfig.DeveloperName == visionConfigName) {
                        config = mockConfig;
                        break;
                    }
                }
                if (config == null) { 
                    config = new LLM_Configuration__mdt(
                        DeveloperName = visionConfigName, 
                        API_Key__c = 'test_vision_api_key', 
                        Base_URL__c = 'https://api.openai.com/v1/chat/completions', 
                    Model_Name__c = 'gpt-4o', 
                        Provider__c = 'OpenAI', 
                    Supports_Files__c = true,
                    Max_Tokens__c = 4000, // Default max tokens for mock
                    Temperature__c = 0.5 // Default temperature for mock
                    );
                }
            } else {
                List<LLM_Configuration__mdt> configs = [
                SELECT Id, API_Key__c, Base_URL__c, Model_Name__c, Provider__c, Max_Tokens__c, Temperature__c
                    FROM LLM_Configuration__mdt 
                    WHERE DeveloperName = :visionConfigName
                    LIMIT 1
                ];
                if (configs.isEmpty()) {
                    System.debug('Error: LLM Configuration not found for: ' + visionConfigName);
                throw new AuraHandledException('Error: AI Model configuration for PDF analysis (' + visionConfigName + ') not found or inactive.');
                }
                config = configs[0];
            }

        try { // TRY BLOCK STARTS HERE
            // --- Master list for all content items (text prompt + all files) ---
            List<Map<String, Object>> allContentItems = new List<Map<String, Object>>();
            
            // --- Build the detailed prompt for the AI ---
            String detailedPrompt = userPrompt + 
                '\n\nYou are analyzing ' + contentDocumentIds.size() + ' PDF document(s). '+
                'For EACH document, please provide a detailed analysis with the following structure. Ensure each document\'s analysis is clearly separated: \n\n';

            List<String> fileTitlesForPrompt = new List<String>();
            Integer fileIndex = 1;

            // Set a maximum number of documents to process to avoid heap size issues
            Integer MAX_DOCUMENTS = 3;
            Integer documentCount = 0;
            
            // --- Prepare file data and update prompt with file details ---
            for (String docId : contentDocumentIds) {
                // Skip if we've reached our document limit
                if (documentCount >= MAX_DOCUMENTS) {
                    System.debug('Skipping additional PDF documents past the limit of ' + MAX_DOCUMENTS);
                    detailedPrompt += '(Additional documents beyond the ' + MAX_DOCUMENTS + ' document limit are not included in this analysis)\n';
                    break;
                }
                
                ContentVersion cv;
                try {
                    cv = [
                        SELECT Id, Title, FileExtension, VersionData
                        FROM ContentVersion
                        WHERE ContentDocumentId = :docId AND IsLatest = true AND FileExtension = 'pdf'
                        LIMIT 1
                    ];
                } catch (Exception e) {
                    System.debug('Warning: PDF ContentVersion not found for ContentDocumentId: ' + docId + '. Skipping this document.');
                    detailedPrompt += 'Document ID ' + docId + ' (Not Found or Not a PDF) - SKIPPED\n';
                    continue; // Skip to the next document
                }

                // Set a stricter size limit for PDFs to avoid heap issues
                Integer MAX_FILE_SIZE_BYTES = 3 * 1024 * 1024; // 3MB
                if (cv.VersionData.size() > MAX_FILE_SIZE_BYTES) {
                    System.debug('Warning: PDF file size exceeds limit for ' + cv.Title + '. Size: ' + cv.VersionData.size() + ' bytes. Max allowed: ' + MAX_FILE_SIZE_BYTES + ' bytes. Skipping this document.');
                    detailedPrompt += cv.Title + ' (File Size Exceeds Limit: ' + (cv.VersionData.size() / (1024 * 1024)) + ' MB) - SKIPPED\n';
                    continue; // Skip to the next document
                }
                
                String base64Data = EncodingUtil.base64Encode(cv.VersionData);
                String base64WithPrefix = 'data:application/pdf;base64,' + base64Data;
                String currentFileTitle = cv.Title + (cv.Title.toLowerCase().endsWith('.pdf') ? '' : '.pdf');
                fileTitlesForPrompt.add(currentFileTitle);

                // Add to detailed prompt
                detailedPrompt += 'DOCUMENT ' + fileIndex + ': "' + currentFileTitle + '"\n';

                // Prepare file content for API request
                Map<String, Object> fileContent = new Map<String, Object>();
                fileContent.put('type', 'file'); // Using 'file' type based on assumption it's supported by gpt-4o for PDFs
            
                Map<String, String> fileDataMap = new Map<String, String>();
                fileDataMap.put('filename', currentFileTitle);
                fileDataMap.put('file_data', base64WithPrefix); // Assuming this is the correct way to pass file data
            
                fileContent.put('file', fileDataMap);
                allContentItems.add(fileContent);
                documentCount++;
                fileIndex++;
                
                System.debug('Added PDF for analysis: ' + currentFileTitle + ' (' + (cv.VersionData.size() / 1024) + ' KB)');
            }
            
            // Monitor the heap size
            Long heapSize = Limits.getHeapSize();
            Long heapLimit = Limits.getLimitHeapSize();
            System.debug('Current heap size: ' + heapSize + ' of ' + heapLimit + ' (' + (heapSize * 100 / heapLimit) + '%)');
            
            // Check if any valid files were found
            if (allContentItems.isEmpty()) {
                 System.debug('No valid PDF documents found or all were skipped.');
                 return 'No valid PDF documents were found to analyze. Please check attachment types and sizes.';
            }

            // --- Revised Prompt Instructions ---
            detailedPrompt = userPrompt + // Keep the original user prompt if it contains specific questions about the docs
                '\n\nYOU ARE AN AI DOCUMENT ANALYZER. PROVIDE A DETAILED ANALYSIS FOR EACH OF THE ' + fileTitlesForPrompt.size() + ' PDF DOCUMENT(S) LISTED BELOW. FOLLOW THESE INSTRUCTIONS EXACTLY:\n';
            
            for(Integer i = 0; i < fileTitlesForPrompt.size(); i++){
                detailedPrompt += 'DOCUMENT ' + (i+1) + ': "' + fileTitlesForPrompt[i] + '"\n';
            }

            detailedPrompt += '\n\nEXPERT DOCUMENT ANALYSIS INSTRUCTIONS:\n' +
                'You are an expert document analyst. For each PDF, provide a comprehensive, professional analysis following this EXACT structure:\n\n' +
                
                '**FORMATTING REQUIREMENTS:**\n' +
                '‚Ä¢ Start each document with: <b>Document X: [filename]</b>\n' +
                '‚Ä¢ Use HTML tags only (NO markdown): <b>, <ul>, <li>, <ol>, <br>, <hr>\n' +
                '‚Ä¢ Separate documents with <hr>\n' +
                '‚Ä¢ No conversational language or apologies\n\n' +
                
                '**ANALYSIS STRUCTURE (for each document):**\n\n' +
                
                '<b>Document Type & Purpose:</b>\n' +
                'Identify what type of document this is and its intended purpose\n\n' +
                
                '<b>Executive Summary:</b>\n' +
                'Concise overview highlighting the document\'s main purpose, key stakeholders, and critical information\n\n' +
                
                '<b>Content Analysis:</b>\n' +
                'Comprehensive examination including:\n' +
                '‚Ä¢ All key data points, figures, dates, and identifiers\n' +
                '‚Ä¢ Important names, roles, and organizations\n' +
                '‚Ä¢ Processes, procedures, or workflows described\n' +
                '‚Ä¢ Financial information, amounts, or calculations\n' +
                '‚Ä¢ Compliance or regulatory references\n' +
                '‚Ä¢ Status indicators, approvals, or signatures\n\n' +
                
                '<b>Data Extraction:</b>\n' +
                'Extract ALL specific values in structured format:\n' +
                '‚Ä¢ Names and titles\n' +
                '‚Ä¢ Dates and deadlines\n' +
                '‚Ä¢ Amounts and percentages\n' +
                '‚Ä¢ Reference numbers or IDs\n' +
                '‚Ä¢ Contact information\n' +
                '‚Ä¢ Status or stage indicators\n\n' +
                
                '<b>Quality Assessment:</b>\n' +
                '‚Ä¢ Document completeness (missing signatures, fields, etc.)\n' +
                '‚Ä¢ Potential inconsistencies or anomalies\n' +
                '‚Ä¢ Readability and image quality issues\n\n' +
                
                '<b>Key Insights & Actions:</b>\n' +
                'Critical observations requiring attention, follow-up items, or compliance considerations\n\n';

            // Add the text prompt to the beginning of the content items list
            Map<String, Object> textContent = new Map<String, Object>();
            textContent.put('type', 'text');
            textContent.put('text', detailedPrompt);
            allContentItems.add(0, textContent); // Insert text prompt at the beginning

            // Prepare the HTTP request body for GPT-4o
            Map<String, Object> requestBody = new Map<String, Object>();
            requestBody.put('model', config.Model_Name__c); // e.g., "gpt-4o"

            Map<String, Object> userMessageDetails = new Map<String, Object>();
            userMessageDetails.put('role', 'user');
            userMessageDetails.put('content', allContentItems);

            List<Map<String, Object>> messages = new List<Map<String, Object>>{userMessageDetails};
            requestBody.put('messages', messages);
            
            if(config.Max_Tokens__c != null){
                 requestBody.put('max_tokens', Integer.valueOf(config.Max_Tokens__c));
            } else {
                requestBody.put('max_tokens', 4000); // Default fallback if not set in config
            }
            if(config.Temperature__c != null){
                requestBody.put('temperature', config.Temperature__c);
            }

            // Check if payload exceeds heap size limit
            String requestBodyJson = '';
            try {
                requestBodyJson = JSON.serialize(requestBody);
                System.debug('Request body size: ' + requestBodyJson.length() + ' characters');
                
                if (requestBodyJson.length() > 3000000) { // Arbitrary large limit as warning
                    System.debug('WARNING: Request body is very large (' + requestBodyJson.length() + ' characters)');
                }
            } catch (System.LimitException le) {
                System.debug('ERROR: Request body exceeds heap size limit.');
                throw new AuraHandledException('The document analysis exceeds Salesforce size limits. Please analyze fewer or smaller documents.');
            }

            // Make the callout
            Http http = new Http();
            HttpRequest req = new HttpRequest();
            req.setEndpoint(config.Base_URL__c);
            req.setMethod('POST');
            req.setHeader('Content-Type', 'application/json;charset=UTF-8');
            req.setHeader('Authorization', 'Bearer ' + config.API_Key__c);
            req.setBody(requestBodyJson);
            req.setTimeout(120000); // 2 minutes timeout

            HttpResponse res = http.send(req);

            // Process the response
            if (res.getStatusCode() == 200) {
                Map<String, Object> responseMap = (Map<String, Object>)JSON.deserializeUntyped(res.getBody());
                if (responseMap.containsKey('choices')) {
                    List<Object> choices = (List<Object>)responseMap.get('choices');
                    if (choices != null && !choices.isEmpty()) {
                        Map<String, Object> choice = (Map<String, Object>)choices[0];
                        if (choice.containsKey('message')) {
                            Map<String, Object> message = (Map<String, Object>)choice.get('message');
                            if (message.containsKey('content')) {
                                String content = (String)message.get('content');
                                System.debug('Successfully received PDF analysis from AI (first 500 chars): ' + content.left(500) + '...');
                                return content;
                            }
                        }
                    }
                }
                System.debug('Error: AI response format unexpected. Body: ' + res.getBody());
                throw new AuraHandledException('Error: AI response format was not as expected.');
            } else {
                String errorBody = res.getBody();
                System.debug('Error from AI Service: ' + res.getStatusCode() + ' ' + res.getStatus() + '. Body: ' + errorBody);
                // Try to parse error for more details
                try {
                    Map<String, Object> errorMap = (Map<String, Object>)JSON.deserializeUntyped(errorBody);
                    if(errorMap.containsKey('error') && errorMap.get('error') instanceof Map<String,Object>){
                        Map<String,Object> errorDetails = (Map<String,Object>)errorMap.get('error');
                        if(errorDetails.containsKey('message')){
                            errorBody = (String)errorDetails.get('message');
                        }
                    }
                } catch(Exception e){
                    // Ignore if error body is not JSON
                }
                throw new AuraHandledException('Error from AI Service: ' + res.getStatusCode() + ' - ' + res.getStatus() + '. Details: ' + errorBody);
            }

        } catch (Exception e) {
            System.debug('ERROR in processPdfDocumentWithAI: ' + e.getMessage() + ' at line ' + e.getLineNumber());
            System.debug('Stack trace: ' + e.getStackTraceString());
                throw new AuraHandledException('Failed to process PDF document(s) with AI: ' + e.getMessage());
        }
    }

    /**
     * @description Retrieves a list of PDF attachments for a given record.
     * @param recordId The ID of the record to check for PDF attachments.
     * @return List<Map<String, String>> A list of maps, where each map contains 'id' (ContentDocumentId) and 'title' of a PDF.
     */
    @AuraEnabled(cacheable=true)
    public static List<Map<String, String>> getPdfAttachmentsForRecord(String recordId) {
        if (String.isBlank(recordId)) {
            return new List<Map<String, String>>();
        }

        List<Map<String, String>> pdfs = new List<Map<String, String>>();
        try {
            List<ContentDocumentLink> links = [SELECT ContentDocumentId 
                                               FROM ContentDocumentLink 
                                               WHERE LinkedEntityId = :recordId];
            
            if (links.isEmpty()) {
                return pdfs;
            }

            Set<Id> contentDocumentIds = new Set<Id>();
            for(ContentDocumentLink link : links) {
                contentDocumentIds.add(link.ContentDocumentId);
            }

            List<ContentVersion> versions = [SELECT ContentDocumentId, Title, FileExtension
                                             FROM ContentVersion 
                                             WHERE ContentDocumentId IN :contentDocumentIds 
                                             AND IsLatest = true 
                                             AND FileExtension = 'pdf'];
            
            // Use a set to ensure we only add each ContentDocumentId once, even if it had multiple versions (though IsLatest should handle this)
            Set<Id> processedDocIds = new Set<Id>();
            for (ContentVersion cv : versions) {
                if (!processedDocIds.contains(cv.ContentDocumentId)) {
                    Map<String, String> pdfInfo = new Map<String, String>();
                    pdfInfo.put('id', cv.ContentDocumentId);
                    pdfInfo.put('title', cv.Title);
                    pdfs.add(pdfInfo);
                    processedDocIds.add(cv.ContentDocumentId);
                }
            }
        } catch (Exception e) {
            System.debug('Error in getPdfAttachmentsForRecord: ' + e.getMessage());
            // Optionally, throw AuraHandledException or return empty list
        }
        return pdfs;
    }

    /**
     * @description Gets metadata for the object type of the specified record Id 
     * Uses server-side permissions instead of client-side, avoiding potential permission issues
     * @param recordId The Id of the record to get object metadata for
     * @return Map<String, Object> Object metadata information
     */
    @AuraEnabled
    public static Map<String, Object> getObjectMetadataFromId(String recordId) {
        try {
            // Ensure we have a valid ID
            if (String.isBlank(recordId)) {
                throw new AuraHandledException('Record ID is required');
            }
            
            Id recordIdValue = Id.valueOf(recordId);
            Schema.SObjectType objectType = recordIdValue.getSObjectType();
            Schema.DescribeSObjectResult objDescribe = objectType.getDescribe();
            
            // Prepare the result map
            Map<String, Object> result = new Map<String, Object>();
            result.put('objectApiName', objDescribe.getName());
            result.put('objectLabel', objDescribe.getLabel());
            result.put('objectLabelPlural', objDescribe.getLabelPlural());
            result.put('isCustom', objDescribe.isCustom());
            
            // Get field info
            Map<String, Object> fieldsInfo = new Map<String, Object>();
            Map<String, Schema.SObjectField> fieldMap = objDescribe.fields.getMap();
            
            for (String fieldName : fieldMap.keySet()) {
                Schema.DescribeFieldResult field = fieldMap.get(fieldName).getDescribe();
                if (field.isAccessible()) {
                    Map<String, Object> fieldInfo = new Map<String, Object>();
                    fieldInfo.put('label', field.getLabel());
                    fieldInfo.put('apiName', field.getName());
                    fieldInfo.put('type', field.getType().name());
                    fieldInfo.put('isRequired', field.isNillable() == false && field.isCreateable());
                    fieldInfo.put('isEditable', field.isUpdateable());
                    
                    // Handle reference fields (lookups/master-detail)
                    if (field.getType() == Schema.DisplayType.REFERENCE) {
                        List<String> referenceTo = new List<String>();
                        for (Schema.SObjectType refType : field.getReferenceTo()) {
                            referenceTo.add(refType.getDescribe().getName());
                        }
                        fieldInfo.put('referenceTo', referenceTo);
                    }
                    
                    fieldsInfo.put(fieldName, fieldInfo);
                }
            }
            
            result.put('fields', fieldsInfo);
            return result;
            
        } catch (Exception e) {
            System.debug('Error getting object metadata: ' + e.getMessage());
            throw new AuraHandledException('Error retrieving object metadata: ' + e.getMessage());
        }
    }

    /**
     * @description Extracts potential field values from analyzed document content and gathers current record values and field metadata.
     * @param recordId The Id of the Salesforce record.
     * @param analyzedDocumentContents A list of strings, where each string is the AI-analyzed content of a document.
     * @param targetFieldApiNames A list of field API names to extract values for.
     * @param llmConfigName The DeveloperName of the LLM configuration to use for AI-powered data extraction.
     * @return Map<String, Object> containing field metadata, current values, and AI-suggested values for each target field.
     */
    @AuraEnabled
    public static Map<String, Object> extractFieldsFromDocuments(
        String recordId, 
        List<String> analyzedDocumentContents, 
        List<String> targetFieldApiNames, 
        String llmConfigName
    ) {
        System.debug(
            'Starting extractFieldsFromDocuments. RecordId: ' + recordId + 
            ', TargetFields: ' + String.join(targetFieldApiNames, ', ') + 
            ', Config: ' + llmConfigName + 
            ', Documents to process: ' + (analyzedDocumentContents != null ? String.valueOf(analyzedDocumentContents.size()) : '0')
        );

        if (String.isBlank(recordId) || 
            analyzedDocumentContents == null || analyzedDocumentContents.isEmpty() || 
            targetFieldApiNames == null || targetFieldApiNames.isEmpty() || 
            String.isBlank(llmConfigName)) {
            throw new AuraHandledException('Missing required parameters for field extraction.');
        }

        Map<String, Object> result = new Map<String, Object>();
        Map<String, Map<String, Object>> fieldsData = new Map<String, Map<String, Object>>();

        try {
            // 1. Get Object Metadata (including field labels and types for all target fields)
            Schema.SObjectType sObjectType = Id.valueOf(recordId).getSObjectType();
            String objectApiName = sObjectType.getDescribe().getName();
            Map<String, Schema.SObjectField> allFieldsMap = sObjectType.getDescribe().fields.getMap();
            
            List<String> fieldsToQueryForCurrentValues = new List<String>();
            for (String fieldName : targetFieldApiNames) {
                if (allFieldsMap.containsKey(fieldName)) {
                    Schema.DescribeFieldResult dfr = allFieldsMap.get(fieldName).getDescribe();
                    if (dfr.isAccessible()) {
                        Map<String, Object> fieldInfo = new Map<String, Object>();
                        fieldInfo.put('apiName', fieldName);
                        fieldInfo.put('label', dfr.getLabel());
                        fieldInfo.put('type', dfr.getType().name());
                        fieldInfo.put('currentValue', null); // Initialize current value
                        fieldInfo.put('suggestedValues', new List<String>());
                        fieldsData.put(fieldName, fieldInfo);
                        fieldsToQueryForCurrentValues.add(fieldName);
                    } else {
                        System.debug('Field not accessible: ' + fieldName);
                    }
                } else {
                    System.debug('Field not found on object: ' + fieldName);
                }
            }

            if (fieldsData.isEmpty()) {
                throw new AuraHandledException('No accessible target fields found or specified.');
            }

            // 2. Get Current Values from the Record
            if (!fieldsToQueryForCurrentValues.isEmpty()) {
                String soqlQuery = 'SELECT ' + String.join(fieldsToQueryForCurrentValues, ',') + 
                                   ' FROM ' + objectApiName + 
                                   ' WHERE Id = :recordId LIMIT 1';
                SObject currentRecord = Database.query(soqlQuery);
                for (String fieldName : fieldsToQueryForCurrentValues) {
                    if (fieldsData.containsKey(fieldName)) {
                        ((Map<String, Object>)fieldsData.get(fieldName)).put('currentValue', currentRecord.get(fieldName));
                    }
                }
            }

            // 3. Prepare prompt for AI to extract values for target fields from document contents
            String combinedDocumentText = String.join(analyzedDocumentContents, '\n\n--- END OF DOCUMENT --- \n\n');
            
            String extractionPrompt = 'You are an expert data extraction specialist. Extract specific field values from document text with high accuracy.\n\n';
            extractionPrompt += 'FIELDS TO EXTRACT: ' + String.join(targetFieldApiNames, ', ') + '\n\n';
            extractionPrompt += 'EXTRACTION RULES:\n';
            extractionPrompt += '1. **Field Type Intelligence**: Analyze field names to understand expected data types:\n';
            extractionPrompt += '   ‚Ä¢ Names (Name, First_Name__c): Extract proper names\n';
            extractionPrompt += '   ‚Ä¢ Dates (Date__c, Birthdate__c): Look for any date format (MM/DD/YYYY, DD-MM-YYYY, etc.)\n';
            extractionPrompt += '   ‚Ä¢ Numbers (Amount__c, Count__c): Extract numeric values\n';
            extractionPrompt += '   ‚Ä¢ IDs/References: Extract alphanumeric identifiers\n';
            extractionPrompt += '   ‚Ä¢ Status/Picklist fields: Extract status-like terms\n\n';
            extractionPrompt += '2. **Multiple Values**: If multiple potential values exist for a field, include all distinct options\n';
            extractionPrompt += '3. **Context Awareness**: Consider surrounding text context to validate extracted values\n';
            extractionPrompt += '4. **Format Consistency**: Standardize similar values (e.g., dates to YYYY-MM-DD when possible)\n';
            extractionPrompt += '- Present your findings ONLY as a JSON object where keys are the exact field API names provided in the \'Requested Fields to Extract\' list.\n';
            extractionPrompt += '- The value for each key (field API name) should be a JSON array of strings, representing the distinct potential values found for that field. Example: ["Value1", "Value2"].\n';
            extractionPrompt += '- If no values are found for a field, provide an empty array: [].\n';
            extractionPrompt += '- Do NOT include any conversational text, explanations, apologies, or any text outside of the single JSON object response.\n';
            extractionPrompt += 'Example of expected JSON output format:\n';
            extractionPrompt += '{\n'; // Start of JSON example
            extractionPrompt += '  "FieldName1__c": ["Potential Value A for Field1", "Potential Value B for Field1"],\n';
            extractionPrompt += '  "AnotherField__c": ["Single Value for AnotherField"],\n';
            extractionPrompt += '  "DateField__c": ["2023-01-15", "15/01/2023"],\n';
            extractionPrompt += '  "FieldWithNoValueFound__c": []\n';
            extractionPrompt += '}\n\n'; // End of JSON example
            extractionPrompt += 'DOCUMENT TEXT TO ANALYZE:\n';
            extractionPrompt += combinedDocumentText;

            // 4. Call LLM for extraction
            LLM_Configuration__mdt llmConfig;
            if (Test.isRunningTest() && !mockConfigurations.isEmpty()) {
                 for (LLM_Configuration__mdt mock : mockConfigurations) { if (mock.DeveloperName == llmConfigName) { llmConfig = mock; break; } }
                 if (llmConfig == null) { llmConfig = new LLM_Configuration__mdt(DeveloperName = llmConfigName, API_Key__c = 'test_key', Base_URL__c = 'test_url', Model_Name__c = 'test_model', Provider__c = 'OpenAI', Max_Tokens__c = 2000, Temperature__c = 0.2); }
            } else {
                List<LLM_Configuration__mdt> configs = [SELECT API_Key__c, Base_URL__c, Model_Name__c, Provider__c, Max_Tokens__c, Temperature__c FROM LLM_Configuration__mdt WHERE DeveloperName = :llmConfigName LIMIT 1]; // Removed IsActive__c = true
                if (configs.isEmpty()) { throw new AuraHandledException('LLM Configuration \'' + llmConfigName + '\' not found.'); } // Updated error message
                llmConfig = configs[0];
            }
            
            // Use a low temperature for more deterministic extraction if supported, or default. Max tokens might need adjustment.
            // The makeLLMCall method in this class is already quite generic. We might need to adjust its internal prompt engineering if it adds too much conversational fluff.
            // For this extraction, we want as raw a JSON response as possible.
            String extractionResultJson = makeLLMCall(llmConfig, extractionPrompt);
            System.debug('LLMController.extractFieldsFromDocuments - AI Extraction Result (Raw JSON string): ' + extractionResultJson);

            // --- MODIFICATION: Clean the JSON string before parsing ---
            String cleanedJson = extractionResultJson;
            if (cleanedJson != null) {
                // Remove markdown code block fences if present
                if (cleanedJson.startsWith('```json')) {
                    cleanedJson = cleanedJson.substring('```json'.length());
                    if (cleanedJson.endsWith('```')) {
                        cleanedJson = cleanedJson.substring(0, cleanedJson.length() - '```'.length());
                    }
                } else if (cleanedJson.startsWith('```')) { // Handle if only ``` is present without 'json'
                    cleanedJson = cleanedJson.substring('```'.length());
                     if (cleanedJson.endsWith('```')) {
                        cleanedJson = cleanedJson.substring(0, cleanedJson.length() - '```'.length());
                    }
                }
                cleanedJson = cleanedJson.trim(); // Trim any leading/trailing whitespace
            }
            System.debug('LLMController.extractFieldsFromDocuments - Cleaned JSON string for parsing: ' + cleanedJson);
            // --- END MODIFICATION ---

            // 5. Parse AI response and populate suggestedValues
            try {
                Map<String, Object> aiSuggestions = (Map<String, Object>)JSON.deserializeUntyped(cleanedJson); // Use cleanedJson
                System.debug('LLMController.extractFieldsFromDocuments - Parsed AI Suggestions Map: ' + JSON.serialize(aiSuggestions));

                for (String fieldName : targetFieldApiNames) {
                    if (fieldsData.containsKey(fieldName) && aiSuggestions.containsKey(fieldName)) {
                        Object rawSuggestions = aiSuggestions.get(fieldName);
                        if (rawSuggestions instanceof List<Object>) {
                            List<String> suggestionsForField = new List<String>();
                            for (Object sugg : (List<Object>)rawSuggestions) {
                                if (sugg instanceof String) {
                                    suggestionsForField.add((String)sugg);
                                }
                            }
                            ((Map<String, Object>)fieldsData.get(fieldName)).put('suggestedValues', suggestionsForField);
                            System.debug('LLMController.extractFieldsFromDocuments - Suggestions for field ' + fieldName + ': ' + JSON.serialize(suggestionsForField));
                        }
                    }
                }
            } catch (Exception jsonEx) {
                System.debug('Error parsing AI JSON response for field extraction: ' + jsonEx.getMessage() + '. Response was: ' + extractionResultJson);
                // Optionally, don't throw an error here, just proceed without AI suggestions or with an error flag per field.
                // For now, we'll let it proceed and the LWC will see empty suggestions.
            }

            result.put('fields', fieldsData);
            System.debug('LLMController.extractFieldsFromDocuments - Final data being returned to LWC: ' + JSON.serialize(result));
            return result;

        } catch (Exception e) {
            System.debug('Error in extractFieldsFromDocuments: ' + e.getMessage() + ' Stack: ' + e.getStackTraceString());
            throw new AuraHandledException('Error extracting field data from documents: ' + e.getMessage());
        }
    }

    /**
     * @description Saves multiple field values to a specified record.
     * @param recordId The Id of the Salesforce record to update.
     * @param fieldsToUpdate A Map where keys are field API names and values are the new values to save.
     * @return void
     * @throws AuraHandledException if an error occurs during processing.
     */
    @AuraEnabled
    public static void updateRecordFields(String recordId, Map<String, Object> fieldsToUpdate) {
        System.debug('Starting updateRecordFields. RecordId: ' + recordId + ', Fields to update count: ' + fieldsToUpdate.size());

        if (String.isBlank(recordId) || fieldsToUpdate == null || fieldsToUpdate.isEmpty()) {
            throw new AuraHandledException('Missing required parameters: recordId and fieldsToUpdate are required.');
        }

        try {
            Schema.SObjectType sObjectType = Id.valueOf(recordId).getSObjectType();
            SObject recordToUpdate = sObjectType.newSObject(recordId); // Creates an SObject for update with the given Id

            Map<String, Schema.SObjectField> fieldMap = sObjectType.getDescribe().fields.getMap();

            for (String fieldApiName : fieldsToUpdate.keySet()) {
                if (fieldMap.containsKey(fieldApiName)) {
                    Schema.DescribeFieldResult fieldDescribe = fieldMap.get(fieldApiName).getDescribe();
                    if (!fieldDescribe.isUpdateable()) {
                        // Soft error or skip? For now, log and skip.
                        System.debug('Field ' + fieldApiName + ' is not updateable. Skipping this field.');
                        continue;
                    }
                    
                    Object valueToSave = fieldsToUpdate.get(fieldApiName);
                    
                    // Basic type coercion - can be expanded if needed
                    Schema.DisplayType fieldType = fieldDescribe.getType();
                    try {
                        if (valueToSave == null) {
                            recordToUpdate.put(fieldApiName, null);
                        } else if (fieldType == Schema.DisplayType.DATE) {
                            if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Date.valueOf((String)valueToSave));
                            } else if (valueToSave instanceof Date) {
                                recordToUpdate.put(fieldApiName, (Date)valueToSave);
                            } else if (valueToSave instanceof Datetime) {
                                recordToUpdate.put(fieldApiName, ((Datetime)valueToSave).date());
                            }
                        } else if (fieldType == Schema.DisplayType.DATETIME) {
                             if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Datetime.valueOf((String)valueToSave));
                            } else if (valueToSave instanceof Datetime) {
                                recordToUpdate.put(fieldApiName, (Datetime)valueToSave);
                            } else if (valueToSave instanceof Date) {
                                recordToUpdate.put(fieldApiName, Datetime.newInstance((Date)valueToSave, Time.newInstance(0,0,0,0)));
                            }
                        } else if (fieldType == Schema.DisplayType.BOOLEAN) {
                            if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Boolean.valueOf((String)valueToSave));
                            } else {
                                recordToUpdate.put(fieldApiName, (Boolean)valueToSave);
                            }
                        } else if (fieldType == Schema.DisplayType.CURRENCY || fieldType == Schema.DisplayType.DOUBLE || fieldType == Schema.DisplayType.PERCENT) {
                            if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Decimal.valueOf((String)valueToSave));
                            } else {
                                recordToUpdate.put(fieldApiName, (Decimal)valueToSave);
                            }
                        } else if (fieldType == Schema.DisplayType.INTEGER) {
                            if (valueToSave instanceof String) {
                                recordToUpdate.put(fieldApiName, Integer.valueOf((String)valueToSave));
                            } else {
                                recordToUpdate.put(fieldApiName, (Integer)valueToSave);
                            }
                        } else {
                            // For String, Picklist, Reference (Id), etc., direct assignment (or String.valueOf for safety)
                            recordToUpdate.put(fieldApiName, String.valueOf(valueToSave)); 
                        }
                    } catch (Exception typeEx) {
                        System.debug('Type conversion error for field ' + fieldApiName + ' with value ' + valueToSave + ': ' + typeEx.getMessage());
                        throw new AuraHandledException('Invalid value format for field ' + fieldDescribe.getLabel() + '. Expected ' + fieldType.name() + '.');
                    }
                } else {
                    System.debug('Field ' + fieldApiName + ' not found on object. Skipping this field.');
                }
            }

            if (!recordToUpdate.getPopulatedFieldsAsMap().isEmpty()) {
                update recordToUpdate;
                System.debug('Record fields updated successfully.');
            } else {
                System.debug('No valid fields were available for update.');
            }

        } catch (Exception e) {
            System.debug('Error in updateRecordFields: ' + e.getMessage() + ' Stack: ' + e.getStackTraceString());
            throw new AuraHandledException('Error updating record fields: ' + e.getMessage());
        }
    }
}